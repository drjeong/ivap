(function webpackUniversalModuleDefinition(root,factory){if(typeof exports==="object"&&typeof module==="object")module.exports=factory(root["_Highcharts"],root["_Highcharts"]["Chart"],root["_Highcharts"]["Axis"],root["_Highcharts"]["Color"],root["_Highcharts"]["SeriesRegistry"],root["_Highcharts"]["RendererRegistry"],root["_Highcharts"]["SVGRenderer"],root["_Highcharts"]["SVGElement"],root["_Highcharts"]["Point"],root["_Highcharts"]["StackItem"]);else if(typeof define==="function"&&define.amd)define("highcharts/modules/gantt",["highcharts/highcharts"],function(amd1){return factory(amd1,amd1["Chart"],amd1["Axis"],amd1["Color"],amd1["SeriesRegistry"],amd1["RendererRegistry"],amd1["SVGRenderer"],amd1["SVGElement"],amd1["Point"],amd1["StackItem"])});else if(typeof exports==="object")exports["highcharts/modules/gantt"]=factory(root["_Highcharts"],root["_Highcharts"]["Chart"],root["_Highcharts"]["Axis"],root["_Highcharts"]["Color"],root["_Highcharts"]["SeriesRegistry"],root["_Highcharts"]["RendererRegistry"],root["_Highcharts"]["SVGRenderer"],root["_Highcharts"]["SVGElement"],root["_Highcharts"]["Point"],root["_Highcharts"]["StackItem"]);else root["Highcharts"]=factory(root["Highcharts"],root["Highcharts"]["Chart"],root["Highcharts"]["Axis"],root["Highcharts"]["Color"],root["Highcharts"]["SeriesRegistry"],root["Highcharts"]["RendererRegistry"],root["Highcharts"]["SVGRenderer"],root["Highcharts"]["SVGElement"],root["Highcharts"]["Point"],root["Highcharts"]["StackItem"])})(typeof window==="undefined"?this:window,(__WEBPACK_EXTERNAL_MODULE__944__,__WEBPACK_EXTERNAL_MODULE__960__,__WEBPACK_EXTERNAL_MODULE__532__,__WEBPACK_EXTERNAL_MODULE__620__,__WEBPACK_EXTERNAL_MODULE__512__,__WEBPACK_EXTERNAL_MODULE__608__,__WEBPACK_EXTERNAL_MODULE__540__,__WEBPACK_EXTERNAL_MODULE__28__,__WEBPACK_EXTERNAL_MODULE__260__,__WEBPACK_EXTERNAL_MODULE__184__)=>{return(()=>{"use strict";var __webpack_modules__={532:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__532__},960:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__960__},620:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__620__},260:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__260__},608:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__608__},28:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__28__},540:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__540__},512:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__512__},184:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__184__},944:module=>{module.exports=__WEBPACK_EXTERNAL_MODULE__944__}};var __webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(cachedModule!==undefined){return cachedModule.exports}var module=__webpack_module_cache__[moduleId]={exports:{}};__webpack_modules__[moduleId](module,module.exports,__webpack_require__);return module.exports}(()=>{__webpack_require__.n=module=>{var getter=module&&module.__esModule?()=>module["default"]:()=>module;__webpack_require__.d(getter,{a:getter});return getter}})();(()=>{__webpack_require__.d=(exports,definition)=>{for(var key in definition){if(__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)){Object.defineProperty(exports,key,{enumerable:true,get:definition[key]})}}}})();(()=>{__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop)})();var __webpack_exports__={};__webpack_require__.d(__webpack_exports__,{default:()=>gantt_src});var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_=__webpack_require__(944);var highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default=__webpack_require__.n(highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_);function arrow(x,y,w,h){return[["M",x,y+h/2],["L",x+w,y],["L",x,y+h/2],["L",x+w,y+h]]}function arrowHalf(x,y,w,h){return arrow(x,y,w/2,h)}function compose(SVGRendererClass){const symbols=SVGRendererClass.prototype.symbols;symbols.arrow=arrow;symbols["arrow-filled"]=triangleLeft;symbols["arrow-filled-half"]=triangleLeftHalf;symbols["arrow-half"]=arrowHalf;symbols["triangle-left"]=triangleLeft;symbols["triangle-left-half"]=triangleLeftHalf}function triangleLeft(x,y,w,h){return[["M",x+w,y],["L",x,y+h/2],["L",x+w,y+h],["Z"]]}function triangleLeftHalf(x,y,w,h){return triangleLeft(x,y,w/2,h)}const ArrowSymbols={compose:compose};const Extensions_ArrowSymbols=ArrowSymbols;const{defined,error,merge,objectEach}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const deg2rad=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().deg2rad,max=Math.max,min=Math.min;class Connection{constructor(from,to,options){this.init(from,to,options)}init(from,to,options){this.fromPoint=from;this.toPoint=to;this.options=options;this.chart=from.series.chart;this.pathfinder=this.chart.pathfinder}renderPath(path,attribs){const connection=this,chart=this.chart,styledMode=chart.styledMode,pathfinder=this.pathfinder,anim={};let pathGraphic=connection.graphics&&connection.graphics.path;if(!pathfinder.group){pathfinder.group=chart.renderer.g().addClass("highcharts-pathfinder-group").attr({zIndex:-1}).add(chart.seriesGroup)}pathfinder.group.translate(chart.plotLeft,chart.plotTop);if(!(pathGraphic&&pathGraphic.renderer)){pathGraphic=chart.renderer.path().add(pathfinder.group);if(!styledMode){pathGraphic.attr({opacity:0})}}pathGraphic.attr(attribs);anim.d=path;if(!styledMode){anim.opacity=1}pathGraphic.animate(anim);this.graphics=this.graphics||{};this.graphics.path=pathGraphic}addMarker(type,options,path){const connection=this,chart=connection.fromPoint.series.chart,pathfinder=chart.pathfinder,renderer=chart.renderer,point=type==="start"?connection.fromPoint:connection.toPoint,anchor=point.getPathfinderAnchorPoint(options);let markerVector,radians,rotation,box,width,height,pathVector,segment;if(!options.enabled){return}if(type==="start"){segment=path[1]}else{segment=path[path.length-2]}if(segment&&segment[0]==="M"||segment[0]==="L"){pathVector={x:segment[1],y:segment[2]};radians=point.getRadiansToVector(pathVector,anchor);markerVector=point.getMarkerVector(radians,options.radius,anchor);rotation=-radians/deg2rad;if(options.width&&options.height){width=options.width;height=options.height}else{width=height=options.radius*2}connection.graphics=connection.graphics||{};box={x:markerVector.x-width/2,y:markerVector.y-height/2,width:width,height:height,rotation:rotation,rotationOriginX:markerVector.x,rotationOriginY:markerVector.y};if(!connection.graphics[type]){connection.graphics[type]=renderer.symbol(options.symbol).addClass("highcharts-point-connecting-path-"+type+"-marker"+" highcharts-color-"+this.fromPoint.colorIndex).attr(box).add(pathfinder.group);if(!renderer.styledMode){connection.graphics[type].attr({fill:options.color||connection.fromPoint.color,stroke:options.lineColor,"stroke-width":options.lineWidth,opacity:0}).animate({opacity:1},point.series.options.animation)}}else{connection.graphics[type].animate(box)}}}getPath(options){const pathfinder=this.pathfinder,chart=this.chart,algorithm=pathfinder.algorithms[options.type];let chartObstacles=pathfinder.chartObstacles;if(typeof algorithm!=="function"){error('"'+options.type+'" is not a Pathfinder algorithm.');return{path:[],obstacles:[]}}if(algorithm.requiresObstacles&&!chartObstacles){chartObstacles=pathfinder.chartObstacles=pathfinder.getChartObstacles(options);chart.options.connectors.algorithmMargin=options.algorithmMargin;pathfinder.chartObstacleMetrics=pathfinder.getObstacleMetrics(chartObstacles)}return algorithm(this.fromPoint.getPathfinderAnchorPoint(options.startMarker),this.toPoint.getPathfinderAnchorPoint(options.endMarker),merge({chartObstacles:chartObstacles,lineObstacles:pathfinder.lineObstacles||[],obstacleMetrics:pathfinder.chartObstacleMetrics,hardBounds:{xMin:0,xMax:chart.plotWidth,yMin:0,yMax:chart.plotHeight},obstacleOptions:{margin:options.algorithmMargin},startDirectionX:pathfinder.getAlgorithmStartDirection(options.startMarker)},options))}render(){const connection=this,fromPoint=connection.fromPoint,series=fromPoint.series,chart=series.chart,pathfinder=chart.pathfinder,attribs={};let options=merge(chart.options.connectors,series.options.connectors,fromPoint.options.connectors,connection.options);if(!chart.styledMode){attribs.stroke=options.lineColor||fromPoint.color;attribs["stroke-width"]=options.lineWidth;if(options.dashStyle){attribs.dashstyle=options.dashStyle}}attribs["class"]="highcharts-point-connecting-path "+"highcharts-color-"+fromPoint.colorIndex;options=merge(attribs,options);if(!defined(options.marker.radius)){options.marker.radius=min(max(Math.ceil((options.algorithmMargin||8)/2)-1,1),5)}const pathResult=connection.getPath(options),path=pathResult.path;if(pathResult.obstacles){pathfinder.lineObstacles=pathfinder.lineObstacles||[];pathfinder.lineObstacles=pathfinder.lineObstacles.concat(pathResult.obstacles)}connection.renderPath(path,attribs);connection.addMarker("start",merge(options.marker,options.startMarker),path);connection.addMarker("end",merge(options.marker,options.endMarker),path)}destroy(){if(this.graphics){objectEach(this.graphics,function(val){val.destroy()});delete this.graphics}}}const Gantt_Connection=Connection;"";const{composed}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{addEvent,merge:CurrentDateIndication_merge,pushUnique,wrap}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const defaultOptions={color:"#ccd3ff",width:2,label:{format:"%[abdYHM]",formatter:function(value,format){return this.axis.chart.time.dateFormat(format||"",value,true)},rotation:0,style:{fontSize:"0.7em"}}};function CurrentDateIndication_compose(AxisClass,PlotLineOrBandClass){if(pushUnique(composed,"CurrentDateIndication")){addEvent(AxisClass,"afterSetOptions",onAxisAfterSetOptions);addEvent(PlotLineOrBandClass,"render",onPlotLineOrBandRender);wrap(PlotLineOrBandClass.prototype,"getLabelText",wrapPlotLineOrBandGetLabelText)}}function onAxisAfterSetOptions(){const options=this.options,cdiOptions=options.currentDateIndicator;if(cdiOptions){const plotLineOptions=typeof cdiOptions==="object"?CurrentDateIndication_merge(defaultOptions,cdiOptions):CurrentDateIndication_merge(defaultOptions);plotLineOptions.value=Date.now();plotLineOptions.className="highcharts-current-date-indicator";if(!options.plotLines){options.plotLines=[]}options.plotLines.push(plotLineOptions)}}function onPlotLineOrBandRender(){if(this.label){this.label.attr({text:this.getLabelText(this.options.label)})}}function wrapPlotLineOrBandGetLabelText(defaultMethod,defaultLabelOptions){const options=this.options;if(options&&options.className&&options.className.indexOf("highcharts-current-date-indicator")!==-1&&options.label&&typeof options.label.formatter==="function"){options.value=Date.now();return options.label.formatter.call(this,options.value,options.label.format)}return defaultMethod.call(this,defaultLabelOptions)}const CurrentDateIndication={compose:CurrentDateIndication_compose};const Extensions_CurrentDateIndication=CurrentDateIndication;var highcharts_Chart_commonjs_highcharts_Chart_commonjs2_highcharts_Chart_root_Highcharts_Chart_=__webpack_require__(960);var highcharts_Chart_commonjs_highcharts_Chart_commonjs2_highcharts_Chart_root_Highcharts_Chart_default=__webpack_require__.n(highcharts_Chart_commonjs_highcharts_Chart_commonjs2_highcharts_Chart_root_Highcharts_Chart_);const{defaultOptions:GanttChart_defaultOptions}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{isArray,merge:GanttChart_merge,splat}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();class GanttChart extends highcharts_Chart_commonjs_highcharts_Chart_commonjs2_highcharts_Chart_root_Highcharts_Chart_default(){init(userOptions,callback){const xAxisOptions=userOptions.xAxis,yAxisOptions=userOptions.yAxis;let defaultLinkedTo;userOptions.xAxis=userOptions.yAxis=void 0;const options=GanttChart_merge(true,{chart:{type:"gantt"},title:{text:""},legend:{enabled:false},navigator:{series:{type:"gantt"},yAxis:{type:"category"}}},userOptions,{isGantt:true});userOptions.xAxis=xAxisOptions;userOptions.yAxis=yAxisOptions;options.xAxis=(!isArray(userOptions.xAxis)?[userOptions.xAxis||{},{}]:userOptions.xAxis).map((xAxisOptions,i)=>{if(i===1){defaultLinkedTo=0}return GanttChart_merge({grid:{borderColor:"#cccccc",enabled:true},opposite:GanttChart_defaultOptions.xAxis?.opposite??xAxisOptions.opposite??true,linkedTo:defaultLinkedTo},xAxisOptions,{type:"datetime"})});options.yAxis=splat(userOptions.yAxis||{}).map(yAxisOptions=>GanttChart_merge({grid:{borderColor:"#cccccc",enabled:true},staticScale:50,reversed:true,type:yAxisOptions.categories?yAxisOptions.type:"treegrid"},yAxisOptions));super.init(options,callback)}}(function(GanttChart){function ganttChart(a,b,c){return new GanttChart(a,b,c)}GanttChart.ganttChart=ganttChart})(GanttChart||(GanttChart={}));const Chart_GanttChart=GanttChart;var highcharts_Axis_commonjs_highcharts_Axis_commonjs2_highcharts_Axis_root_Highcharts_Axis_=__webpack_require__(532);var highcharts_Axis_commonjs_highcharts_Axis_commonjs2_highcharts_Axis_root_Highcharts_Axis_default=__webpack_require__.n(highcharts_Axis_commonjs_highcharts_Axis_commonjs2_highcharts_Axis_root_Highcharts_Axis_);const{isTouchDevice}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{addEvent:ChartNavigatorComposition_addEvent,merge:ChartNavigatorComposition_merge,pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const composedMembers=[];let NavigatorConstructor;function ChartNavigatorComposition_compose(ChartClass,NavigatorClass){if(highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().pushUnique(composedMembers,ChartClass)){const chartProto=ChartClass.prototype;NavigatorConstructor=NavigatorClass;chartProto.callbacks.push(onChartCallback);ChartNavigatorComposition_addEvent(ChartClass,"afterAddSeries",onChartAfterAddSeries);ChartNavigatorComposition_addEvent(ChartClass,"afterSetChartSize",onChartAfterSetChartSize);ChartNavigatorComposition_addEvent(ChartClass,"afterUpdate",onChartAfterUpdate);ChartNavigatorComposition_addEvent(ChartClass,"beforeRender",onChartBeforeRender);ChartNavigatorComposition_addEvent(ChartClass,"beforeShowResetZoom",onChartBeforeShowResetZoom);ChartNavigatorComposition_addEvent(ChartClass,"update",onChartUpdate)}}function onChartAfterAddSeries(){if(this.navigator){this.navigator.setBaseSeries(null,false)}}function onChartAfterSetChartSize(){const legend=this.legend,navigator=this.navigator;let legendOptions,xAxis,yAxis;if(navigator){legendOptions=legend&&legend.options;xAxis=navigator.xAxis;yAxis=navigator.yAxis;const{scrollbarHeight,scrollButtonSize}=navigator;if(this.inverted){navigator.left=navigator.opposite?this.chartWidth-scrollbarHeight-navigator.height:this.spacing[3]+scrollbarHeight;navigator.top=this.plotTop+scrollButtonSize}else{navigator.left=pick(xAxis.left,this.plotLeft+scrollButtonSize);navigator.top=navigator.navigatorOptions.top||this.chartHeight-navigator.height-scrollbarHeight-(this.scrollbar?.options.margin||0)-this.spacing[2]-(this.rangeSelector&&this.extraBottomMargin?this.rangeSelector.getHeight():0)-(legendOptions&&legendOptions.verticalAlign==="bottom"&&legendOptions.layout!=="proximate"&&legendOptions.enabled&&!legendOptions.floating?legend.legendHeight+pick(legendOptions.margin,10):0)-(this.titleOffset?this.titleOffset[2]:0)}if(xAxis&&yAxis){if(this.inverted){xAxis.options.left=yAxis.options.left=navigator.left}else{xAxis.options.top=yAxis.options.top=navigator.top}xAxis.setAxisSize();yAxis.setAxisSize()}}}function onChartAfterUpdate(event){if(!this.navigator&&!this.scroller&&(this.options.navigator.enabled||this.options.scrollbar.enabled)){this.scroller=this.navigator=new NavigatorConstructor(this);if(pick(event.redraw,true)){this.redraw(event.animation)}}}function onChartBeforeRender(){const options=this.options;if(options.navigator.enabled||options.scrollbar.enabled){this.scroller=this.navigator=new NavigatorConstructor(this)}}function onChartBeforeShowResetZoom(){const chartOptions=this.options,navigator=chartOptions.navigator,rangeSelector=chartOptions.rangeSelector;if((navigator&&navigator.enabled||rangeSelector&&rangeSelector.enabled)&&(!isTouchDevice&&this.zooming.type==="x"||isTouchDevice&&this.zooming.pinchType==="x")){return false}}function onChartCallback(chart){const navigator=chart.navigator;if(navigator&&chart.xAxis[0]){const extremes=chart.xAxis[0].getExtremes();navigator.render(extremes.min,extremes.max)}}function onChartUpdate(e){const navigatorOptions=e.options.navigator||{},scrollbarOptions=e.options.scrollbar||{};if(!this.navigator&&!this.scroller&&(navigatorOptions.enabled||scrollbarOptions.enabled)){ChartNavigatorComposition_merge(true,this.options.navigator,navigatorOptions);ChartNavigatorComposition_merge(true,this.options.scrollbar,scrollbarOptions);delete e.options.navigator;delete e.options.scrollbar}}const ChartNavigatorComposition={compose:ChartNavigatorComposition_compose};const Navigator_ChartNavigatorComposition=ChartNavigatorComposition;const{isTouchDevice:NavigatorAxisComposition_isTouchDevice}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{addEvent:NavigatorAxisComposition_addEvent,correctFloat,defined:NavigatorAxisComposition_defined,isNumber,pick:NavigatorAxisComposition_pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function onAxisInit(){const axis=this;if(!axis.navigatorAxis){axis.navigatorAxis=new NavigatorAxisAdditions(axis)}}function onAxisSetExtremes(e){const axis=this,chart=axis.chart,chartOptions=chart.options,navigator=chartOptions.navigator,navigatorAxis=axis.navigatorAxis,pinchType=chart.zooming.pinchType,rangeSelector=chartOptions.rangeSelector,zoomType=chart.zooming.type;let zoomed;if(axis.isXAxis&&(navigator?.enabled||rangeSelector?.enabled)){if(zoomType==="y"&&e.trigger==="zoom"){zoomed=false}else if((e.trigger==="zoom"&&zoomType==="xy"||NavigatorAxisComposition_isTouchDevice&&pinchType==="xy")&&axis.options.range){const previousZoom=navigatorAxis.previousZoom;if(NavigatorAxisComposition_defined(e.min)){navigatorAxis.previousZoom=[axis.min,axis.max]}else if(previousZoom){e.min=previousZoom[0];e.max=previousZoom[1];navigatorAxis.previousZoom=void 0}}}if(typeof zoomed!=="undefined"){e.preventDefault()}}class NavigatorAxisAdditions{static compose(AxisClass){if(!AxisClass.keepProps.includes("navigatorAxis")){AxisClass.keepProps.push("navigatorAxis");NavigatorAxisComposition_addEvent(AxisClass,"init",onAxisInit);NavigatorAxisComposition_addEvent(AxisClass,"setExtremes",onAxisSetExtremes)}}constructor(axis){this.axis=axis}destroy(){this.axis=void 0}toFixedRange(pxMin,pxMax,fixedMin,fixedMax){const axis=this.axis,halfPointRange=(axis.pointRange||0)/2;let newMin=NavigatorAxisComposition_pick(fixedMin,axis.translate(pxMin,true,!axis.horiz)),newMax=NavigatorAxisComposition_pick(fixedMax,axis.translate(pxMax,true,!axis.horiz));if(!NavigatorAxisComposition_defined(fixedMin)){newMin=correctFloat(newMin+halfPointRange)}if(!NavigatorAxisComposition_defined(fixedMax)){newMax=correctFloat(newMax-halfPointRange)}if(!isNumber(newMin)||!isNumber(newMax)){newMin=newMax=void 0}return{min:newMin,max:newMax}}}const NavigatorAxisComposition=NavigatorAxisAdditions;var highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_=__webpack_require__(620);var highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default=__webpack_require__.n(highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_);var highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_=__webpack_require__(512);var highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default=__webpack_require__.n(highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_);const{parse:color}=highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default();const{seriesTypes}=highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default();const NavigatorDefaults={height:40,margin:25,maskInside:true,handles:{width:7,borderRadius:0,height:15,symbols:["navigator-handle","navigator-handle"],enabled:true,lineWidth:1,backgroundColor:"#f2f2f2",borderColor:"#999999"},maskFill:color("#667aff").setOpacity(.3).get(),outlineColor:"#999999",outlineWidth:1,series:{type:typeof seriesTypes.areaspline==="undefined"?"line":"areaspline",fillOpacity:.05,lineWidth:1,compare:null,sonification:{enabled:false},dataGrouping:{approximation:"average",enabled:true,groupPixelWidth:2,firstAnchor:"firstPoint",anchor:"middle",lastAnchor:"lastPoint",units:[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,5,10,15,30]],["hour",[1,2,3,4,6,8,12]],["day",[1,2,3,4]],["week",[1,2,3]],["month",[1,3,6]],["year",null]]},dataLabels:{enabled:false,zIndex:2},id:"highcharts-navigator-series",className:"highcharts-navigator-series",lineColor:null,marker:{enabled:false},threshold:null},xAxis:{className:"highcharts-navigator-xaxis",tickLength:0,lineWidth:0,gridLineColor:"#e6e6e6",id:"navigator-x-axis",gridLineWidth:1,tickPixelInterval:200,labels:{align:"left",style:{color:"#000000",fontSize:"0.7em",opacity:.6,textOutline:"2px contrast"},x:3,y:-4},crosshair:false},yAxis:{className:"highcharts-navigator-yaxis",gridLineWidth:0,startOnTick:false,endOnTick:false,minPadding:.1,id:"navigator-y-axis",maxPadding:.1,labels:{enabled:false},crosshair:false,title:{text:null},tickLength:0,tickWidth:0}};const Navigator_NavigatorDefaults=NavigatorDefaults;"";const{defined:Symbols_defined,isNumber:Symbols_isNumber,pick:Symbols_pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function arc(cx,cy,w,h,options){const arc=[];if(options){const start=options.start||0,rx=Symbols_pick(options.r,w),ry=Symbols_pick(options.r,h||w),proximity=2e-4/(options.borderRadius?1:Math.max(rx,1)),fullCircle=Math.abs((options.end||0)-start-2*Math.PI)<proximity,end=(options.end||0)-(fullCircle?proximity:0),innerRadius=options.innerR,open=Symbols_pick(options.open,fullCircle),cosStart=Math.cos(start),sinStart=Math.sin(start),cosEnd=Math.cos(end),sinEnd=Math.sin(end),longArc=Symbols_pick(options.longArc,end-start-Math.PI<proximity?0:1);let arcSegment=["A",rx,ry,0,longArc,Symbols_pick(options.clockwise,1),cx+rx*cosEnd,cy+ry*sinEnd];arcSegment.params={start:start,end:end,cx:cx,cy:cy};arc.push(["M",cx+rx*cosStart,cy+ry*sinStart],arcSegment);if(Symbols_defined(innerRadius)){arcSegment=["A",innerRadius,innerRadius,0,longArc,Symbols_defined(options.clockwise)?1-options.clockwise:0,cx+innerRadius*cosStart,cy+innerRadius*sinStart];arcSegment.params={start:end,end:start,cx:cx,cy:cy};arc.push(open?["M",cx+innerRadius*cosEnd,cy+innerRadius*sinEnd]:["L",cx+innerRadius*cosEnd,cy+innerRadius*sinEnd],arcSegment)}if(!open){arc.push(["Z"])}}return arc}function callout(x,y,w,h,options){const arrowLength=6,halfDistance=6,r=Math.min(options&&options.r||0,w,h),safeDistance=r+halfDistance,anchorX=options&&options.anchorX,anchorY=options&&options.anchorY||0;const path=roundedRect(x,y,w,h,{r:r});if(!Symbols_isNumber(anchorX)){return path}if(anchorX<w&&anchorX>0&&anchorY<h&&anchorY>0){return path}if(x+anchorX>w-safeDistance){if(anchorY>y+safeDistance&&anchorY<y+h-safeDistance){path.splice(3,1,["L",x+w,anchorY-halfDistance],["L",x+w+arrowLength,anchorY],["L",x+w,anchorY+halfDistance],["L",x+w,y+h-r])}else{if(anchorX<w){const isTopCorner=anchorY<y+safeDistance,cornerY=isTopCorner?y:y+h,sliceStart=isTopCorner?2:5;path.splice(sliceStart,0,["L",anchorX,anchorY],["L",x+w-r,cornerY])}else{path.splice(3,1,["L",x+w,h/2],["L",anchorX,anchorY],["L",x+w,h/2],["L",x+w,y+h-r])}}}else if(x+anchorX<safeDistance){if(anchorY>y+safeDistance&&anchorY<y+h-safeDistance){path.splice(7,1,["L",x,anchorY+halfDistance],["L",x-arrowLength,anchorY],["L",x,anchorY-halfDistance],["L",x,y+r])}else{if(anchorX>0){const isTopCorner=anchorY<y+safeDistance,cornerY=isTopCorner?y:y+h,sliceStart=isTopCorner?1:6;path.splice(sliceStart,0,["L",anchorX,anchorY],["L",x+r,cornerY])}else{path.splice(7,1,["L",x,h/2],["L",anchorX,anchorY],["L",x,h/2],["L",x,y+r])}}}else if(anchorY>h&&anchorX<w-safeDistance){path.splice(5,1,["L",anchorX+halfDistance,y+h],["L",anchorX,y+h+arrowLength],["L",anchorX-halfDistance,y+h],["L",x+r,y+h])}else if(anchorY<0&&anchorX>safeDistance){path.splice(1,1,["L",anchorX-halfDistance,y],["L",anchorX,y-arrowLength],["L",anchorX+halfDistance,y],["L",w-r,y])}return path}function circle(x,y,w,h){return arc(x+w/2,y+h/2,w/2,h/2,{start:Math.PI*.5,end:Math.PI*2.5,open:false})}function diamond(x,y,w,h){return[["M",x+w/2,y],["L",x+w,y+h/2],["L",x+w/2,y+h],["L",x,y+h/2],["Z"]]}function rect(x,y,w,h,options){if(options&&options.r){return roundedRect(x,y,w,h,options)}return[["M",x,y],["L",x+w,y],["L",x+w,y+h],["L",x,y+h],["Z"]]}function roundedRect(x,y,w,h,options){const r=options?.r||0;return[["M",x+r,y],["L",x+w-r,y],["A",r,r,0,0,1,x+w,y+r],["L",x+w,y+h-r],["A",r,r,0,0,1,x+w-r,y+h],["L",x+r,y+h],["A",r,r,0,0,1,x,y+h-r],["L",x,y+r],["A",r,r,0,0,1,x+r,y],["Z"]]}function triangle(x,y,w,h){return[["M",x+w/2,y],["L",x+w,y+h],["L",x,y+h],["Z"]]}function triangleDown(x,y,w,h){return[["M",x,y],["L",x+w,y],["L",x+w/2,y+h],["Z"]]}const Symbols={arc:arc,callout:callout,circle:circle,diamond:diamond,rect:rect,roundedRect:roundedRect,square:rect,triangle:triangle,"triangle-down":triangleDown};const SVG_Symbols=Symbols;const{relativeLength}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function navigatorHandle(_x,_y,width,height,options={}){const halfWidth=options.width?options.width/2:width,markerPosition=1.5,r=relativeLength(options.borderRadius||0,Math.min(halfWidth*2,height));height=options.height||height;return[["M",-markerPosition,height/2-3.5],["L",-markerPosition,height/2+4.5],["M",markerPosition-1,height/2-3.5],["L",markerPosition-1,height/2+4.5],...SVG_Symbols.rect(-halfWidth-1,.5,halfWidth*2+1,height,{r:r})]}const NavigatorSymbols={"navigator-handle":navigatorHandle};const Navigator_NavigatorSymbols=NavigatorSymbols;var highcharts_RendererRegistry_commonjs_highcharts_RendererRegistry_commonjs2_highcharts_RendererRegistry_root_Highcharts_RendererRegistry_=__webpack_require__(608);var highcharts_RendererRegistry_commonjs_highcharts_RendererRegistry_commonjs2_highcharts_RendererRegistry_root_Highcharts_RendererRegistry_default=__webpack_require__.n(highcharts_RendererRegistry_commonjs_highcharts_RendererRegistry_commonjs2_highcharts_RendererRegistry_root_Highcharts_RendererRegistry_);const{defined:StockUtilities_defined}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function setFixedRange(range){const xAxis=this.xAxis[0];if(StockUtilities_defined(xAxis.dataMax)&&StockUtilities_defined(xAxis.dataMin)&&range){this.fixedRange=Math.min(range,xAxis.dataMax-xAxis.dataMin)}else{this.fixedRange=range}}const StockUtilities={setFixedRange:setFixedRange};const Utilities_StockUtilities=StockUtilities;const{setOptions}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{composed:NavigatorComposition_composed}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{getRendererType}=highcharts_RendererRegistry_commonjs_highcharts_RendererRegistry_commonjs2_highcharts_RendererRegistry_root_Highcharts_RendererRegistry_default();const{setFixedRange:NavigatorComposition_setFixedRange}=Utilities_StockUtilities;const{addEvent:NavigatorComposition_addEvent,extend,pushUnique:NavigatorComposition_pushUnique}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function NavigatorComposition_compose(ChartClass,AxisClass,SeriesClass){NavigatorAxisComposition.compose(AxisClass);if(NavigatorComposition_pushUnique(NavigatorComposition_composed,"Navigator")){ChartClass.prototype.setFixedRange=NavigatorComposition_setFixedRange;extend(getRendererType().prototype.symbols,Navigator_NavigatorSymbols);NavigatorComposition_addEvent(SeriesClass,"afterUpdate",onSeriesAfterUpdate);setOptions({navigator:Navigator_NavigatorDefaults})}}function onSeriesAfterUpdate(){if(this.chart.navigator&&!this.options.isInternal){this.chart.navigator.setBaseSeries(null,false)}}const NavigatorComposition={compose:NavigatorComposition_compose};const Navigator_NavigatorComposition=NavigatorComposition;const{composed:ScrollbarAxis_composed}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{addEvent:ScrollbarAxis_addEvent,defined:ScrollbarAxis_defined,pick:ScrollbarAxis_pick,pushUnique:ScrollbarAxis_pushUnique}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();var ScrollbarAxis;(function(ScrollbarAxis){let Scrollbar;function compose(AxisClass,ScrollbarClass){if(ScrollbarAxis_pushUnique(ScrollbarAxis_composed,"Axis.Scrollbar")){Scrollbar=ScrollbarClass;ScrollbarAxis_addEvent(AxisClass,"afterGetOffset",onAxisAfterGetOffset);ScrollbarAxis_addEvent(AxisClass,"afterInit",onAxisAfterInit);ScrollbarAxis_addEvent(AxisClass,"afterRender",onAxisAfterRender)}}ScrollbarAxis.compose=compose;function getExtremes(axis){const axisMin=ScrollbarAxis_pick(axis.options&&axis.options.min,axis.min);const axisMax=ScrollbarAxis_pick(axis.options&&axis.options.max,axis.max);return{axisMin:axisMin,axisMax:axisMax,scrollMin:ScrollbarAxis_defined(axis.dataMin)?Math.min(axisMin,axis.min,axis.dataMin,ScrollbarAxis_pick(axis.threshold,Infinity)):axisMin,scrollMax:ScrollbarAxis_defined(axis.dataMax)?Math.max(axisMax,axis.max,axis.dataMax,ScrollbarAxis_pick(axis.threshold,-Infinity)):axisMax}}function onAxisAfterGetOffset(){const axis=this,scrollbar=axis.scrollbar,opposite=scrollbar&&!scrollbar.options.opposite,index=axis.horiz?2:opposite?3:1;if(scrollbar){axis.chart.scrollbarsOffsets=[0,0];axis.chart.axisOffset[index]+=scrollbar.size+(scrollbar.options.margin||0)}}function onAxisAfterInit(){const axis=this;if(axis.options&&axis.options.scrollbar&&axis.options.scrollbar.enabled){axis.options.scrollbar.vertical=!axis.horiz;axis.options.startOnTick=axis.options.endOnTick=false;axis.scrollbar=new Scrollbar(axis.chart.renderer,axis.options.scrollbar,axis.chart);ScrollbarAxis_addEvent(axis.scrollbar,"changed",function(e){const{axisMin,axisMax,scrollMin:unitedMin,scrollMax:unitedMax}=getExtremes(axis),range=unitedMax-unitedMin;let to,from;if(!ScrollbarAxis_defined(axisMin)||!ScrollbarAxis_defined(axisMax)){return}if(axis.horiz&&!axis.reversed||!axis.horiz&&axis.reversed){to=unitedMin+range*this.to;from=unitedMin+range*this.from}else{to=unitedMin+range*(1-this.from);from=unitedMin+range*(1-this.to)}if(this.shouldUpdateExtremes(e.DOMType)){const animate=e.DOMType==="mousemove"||e.DOMType==="touchmove"?false:void 0;axis.setExtremes(from,to,true,animate,e)}else{this.setRange(this.from,this.to)}})}}function onAxisAfterRender(){const axis=this,{scrollMin,scrollMax}=getExtremes(axis),scrollbar=axis.scrollbar,offset=axis.axisTitleMargin+(axis.titleOffset||0),scrollbarsOffsets=axis.chart.scrollbarsOffsets,axisMargin=axis.options.margin||0;let offsetsIndex,from,to;if(scrollbar&&scrollbarsOffsets){if(axis.horiz){if(!axis.opposite){scrollbarsOffsets[1]+=offset}scrollbar.position(axis.left,axis.top+axis.height+2+scrollbarsOffsets[1]-(axis.opposite?axisMargin:0),axis.width,axis.height);if(!axis.opposite){scrollbarsOffsets[1]+=axisMargin}offsetsIndex=1}else{if(axis.opposite){scrollbarsOffsets[0]+=offset}let xPosition;if(!scrollbar.options.opposite){xPosition=axis.opposite?0:axisMargin}else{xPosition=axis.left+axis.width+2+scrollbarsOffsets[0]-(axis.opposite?0:axisMargin)}scrollbar.position(xPosition,axis.top,axis.width,axis.height);if(axis.opposite){scrollbarsOffsets[0]+=axisMargin}offsetsIndex=0}scrollbarsOffsets[offsetsIndex]+=scrollbar.size+(scrollbar.options.margin||0);if(isNaN(scrollMin)||isNaN(scrollMax)||!ScrollbarAxis_defined(axis.min)||!ScrollbarAxis_defined(axis.max)||axis.dataMin===axis.dataMax){scrollbar.setRange(0,1)}else if(axis.min===axis.max){const interval=axis.pointRange/(axis.dataMax+1);from=interval*axis.min;to=interval*(axis.max+1);scrollbar.setRange(from,to)}else{from=(axis.min-scrollMin)/(scrollMax-scrollMin);to=(axis.max-scrollMin)/(scrollMax-scrollMin);if(axis.horiz&&!axis.reversed||!axis.horiz&&axis.reversed){scrollbar.setRange(from,to)}else{scrollbar.setRange(1-to,1-from)}}}}})(ScrollbarAxis||(ScrollbarAxis={}));const Axis_ScrollbarAxis=ScrollbarAxis;const ScrollbarDefaults={height:10,barBorderRadius:5,buttonBorderRadius:0,buttonsEnabled:false,liveRedraw:void 0,margin:void 0,minWidth:6,opposite:true,step:.2,zIndex:3,barBackgroundColor:"#cccccc",barBorderWidth:0,barBorderColor:"#cccccc",buttonArrowColor:"#333333",buttonBackgroundColor:"#e6e6e6",buttonBorderColor:"#cccccc",buttonBorderWidth:1,rifleColor:"none",trackBackgroundColor:"rgba(255, 255, 255, 0.001)",trackBorderColor:"#cccccc",trackBorderRadius:5,trackBorderWidth:1};const Scrollbar_ScrollbarDefaults=ScrollbarDefaults;const{defaultOptions:Scrollbar_defaultOptions}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{addEvent:Scrollbar_addEvent,correctFloat:Scrollbar_correctFloat,crisp,defined:Scrollbar_defined,destroyObjectProperties,fireEvent,merge:Scrollbar_merge,pick:Scrollbar_pick,removeEvent}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();class Scrollbar{static compose(AxisClass){Axis_ScrollbarAxis.compose(AxisClass,Scrollbar)}static swapXY(path,vertical){if(vertical){path.forEach(seg=>{const len=seg.length;let temp;for(let i=0;i<len;i+=2){temp=seg[i+1];if(typeof temp==="number"){seg[i+1]=seg[i+2];seg[i+2]=temp}}})}return path}constructor(renderer,options,chart){this._events=[];this.chartX=0;this.chartY=0;this.from=0;this.scrollbarButtons=[];this.scrollbarLeft=0;this.scrollbarStrokeWidth=1;this.scrollbarTop=0;this.size=0;this.to=0;this.trackBorderWidth=1;this.x=0;this.y=0;this.init(renderer,options,chart)}addEvents(){const buttonsOrder=this.options.inverted?[1,0]:[0,1],buttons=this.scrollbarButtons,bar=this.scrollbarGroup.element,track=this.track.element,mouseDownHandler=this.mouseDownHandler.bind(this),mouseMoveHandler=this.mouseMoveHandler.bind(this),mouseUpHandler=this.mouseUpHandler.bind(this);const _events=[[buttons[buttonsOrder[0]].element,"click",this.buttonToMinClick.bind(this)],[buttons[buttonsOrder[1]].element,"click",this.buttonToMaxClick.bind(this)],[track,"click",this.trackClick.bind(this)],[bar,"mousedown",mouseDownHandler],[bar.ownerDocument,"mousemove",mouseMoveHandler],[bar.ownerDocument,"mouseup",mouseUpHandler],[bar,"touchstart",mouseDownHandler],[bar.ownerDocument,"touchmove",mouseMoveHandler],[bar.ownerDocument,"touchend",mouseUpHandler]];_events.forEach(function(args){Scrollbar_addEvent.apply(null,args)});this._events=_events}buttonToMaxClick(e){const scroller=this;const range=(scroller.to-scroller.from)*Scrollbar_pick(scroller.options.step,.2);scroller.updatePosition(scroller.from+range,scroller.to+range);fireEvent(scroller,"changed",{from:scroller.from,to:scroller.to,trigger:"scrollbar",DOMEvent:e})}buttonToMinClick(e){const scroller=this;const range=Scrollbar_correctFloat(scroller.to-scroller.from)*Scrollbar_pick(scroller.options.step,.2);scroller.updatePosition(Scrollbar_correctFloat(scroller.from-range),Scrollbar_correctFloat(scroller.to-range));fireEvent(scroller,"changed",{from:scroller.from,to:scroller.to,trigger:"scrollbar",DOMEvent:e})}cursorToScrollbarPosition(normalizedEvent){const scroller=this,options=scroller.options,minWidthDifference=options.minWidth>scroller.calculatedWidth?options.minWidth:0;return{chartX:(normalizedEvent.chartX-scroller.x-scroller.xOffset)/(scroller.barWidth-minWidthDifference),chartY:(normalizedEvent.chartY-scroller.y-scroller.yOffset)/(scroller.barWidth-minWidthDifference)}}destroy(){const scroller=this,navigator=scroller.chart.scroller;scroller.removeEvents();["track","scrollbarRifles","scrollbar","scrollbarGroup","group"].forEach(function(prop){if(scroller[prop]&&scroller[prop].destroy){scroller[prop]=scroller[prop].destroy()}});if(navigator&&scroller===navigator.scrollbar){navigator.scrollbar=null;destroyObjectProperties(navigator.scrollbarButtons)}}drawScrollbarButton(index){const scroller=this,renderer=scroller.renderer,scrollbarButtons=scroller.scrollbarButtons,options=scroller.options,size=scroller.size,group=renderer.g().add(scroller.group);scrollbarButtons.push(group);if(options.buttonsEnabled){const rect=renderer.rect().addClass("highcharts-scrollbar-button").add(group);if(!scroller.chart.styledMode){rect.attr({stroke:options.buttonBorderColor,"stroke-width":options.buttonBorderWidth,fill:options.buttonBackgroundColor})}rect.attr(rect.crisp({x:-.5,y:-.5,width:size,height:size,r:options.buttonBorderRadius},rect.strokeWidth()));const arrow=renderer.path(Scrollbar.swapXY([["M",size/2+(index?-1:1),size/2-3],["L",size/2+(index?-1:1),size/2+3],["L",size/2+(index?2:-2),size/2]],options.vertical)).addClass("highcharts-scrollbar-arrow").add(scrollbarButtons[index]);if(!scroller.chart.styledMode){arrow.attr({fill:options.buttonArrowColor})}}}init(renderer,options,chart){const scroller=this;scroller.scrollbarButtons=[];scroller.renderer=renderer;scroller.userOptions=options;scroller.options=Scrollbar_merge(Scrollbar_ScrollbarDefaults,Scrollbar_defaultOptions.scrollbar,options);scroller.options.margin=Scrollbar_pick(scroller.options.margin,10);scroller.chart=chart;scroller.size=Scrollbar_pick(scroller.options.size,scroller.options.height);if(options.enabled){scroller.render();scroller.addEvents()}}mouseDownHandler(e){const scroller=this,normalizedEvent=scroller.chart.pointer?.normalize(e)||e,mousePosition=scroller.cursorToScrollbarPosition(normalizedEvent);scroller.chartX=mousePosition.chartX;scroller.chartY=mousePosition.chartY;scroller.initPositions=[scroller.from,scroller.to];scroller.grabbedCenter=true}mouseMoveHandler(e){const scroller=this,normalizedEvent=scroller.chart.pointer?.normalize(e)||e,options=scroller.options,direction=options.vertical?"chartY":"chartX",initPositions=scroller.initPositions||[];let scrollPosition,chartPosition,change;if(scroller.grabbedCenter&&(!e.touches||e.touches[0][direction]!==0)){chartPosition=scroller.cursorToScrollbarPosition(normalizedEvent)[direction];scrollPosition=scroller[direction];change=chartPosition-scrollPosition;scroller.hasDragged=true;scroller.updatePosition(initPositions[0]+change,initPositions[1]+change);if(scroller.hasDragged){fireEvent(scroller,"changed",{from:scroller.from,to:scroller.to,trigger:"scrollbar",DOMType:e.type,DOMEvent:e})}}}mouseUpHandler(e){const scroller=this;if(scroller.hasDragged){fireEvent(scroller,"changed",{from:scroller.from,to:scroller.to,trigger:"scrollbar",DOMType:e.type,DOMEvent:e})}scroller.grabbedCenter=scroller.hasDragged=scroller.chartX=scroller.chartY=null}position(x,y,width,height){const scroller=this,options=scroller.options,{buttonsEnabled,margin=0,vertical}=options,method=scroller.rendered?"animate":"attr";let xOffset=height,yOffset=0;scroller.group.show();scroller.x=x;scroller.y=y+this.trackBorderWidth;scroller.width=width;scroller.height=height;scroller.xOffset=xOffset;scroller.yOffset=yOffset;if(vertical){scroller.width=scroller.yOffset=width=yOffset=scroller.size;scroller.xOffset=xOffset=0;scroller.yOffset=yOffset=buttonsEnabled?scroller.size:0;scroller.barWidth=height-(buttonsEnabled?width*2:0);scroller.x=x=x+margin}else{scroller.height=height=scroller.size;scroller.xOffset=xOffset=buttonsEnabled?scroller.size:0;scroller.barWidth=width-(buttonsEnabled?height*2:0);scroller.y=scroller.y+margin}scroller.group[method]({translateX:x,translateY:scroller.y});scroller.track[method]({width:width,height:height});scroller.scrollbarButtons[1][method]({translateX:vertical?0:width-xOffset,translateY:vertical?height-yOffset:0})}removeEvents(){this._events.forEach(function(args){removeEvent.apply(null,args)});this._events.length=0}render(){const scroller=this,renderer=scroller.renderer,options=scroller.options,size=scroller.size,styledMode=scroller.chart.styledMode,group=renderer.g("scrollbar").attr({zIndex:options.zIndex}).hide().add();scroller.group=group;scroller.track=renderer.rect().addClass("highcharts-scrollbar-track").attr({r:options.trackBorderRadius||0,height:size,width:size}).add(group);if(!styledMode){scroller.track.attr({fill:options.trackBackgroundColor,stroke:options.trackBorderColor,"stroke-width":options.trackBorderWidth})}const trackBorderWidth=scroller.trackBorderWidth=scroller.track.strokeWidth();scroller.track.attr({x:-crisp(0,trackBorderWidth),y:-crisp(0,trackBorderWidth)});scroller.scrollbarGroup=renderer.g().add(group);scroller.scrollbar=renderer.rect().addClass("highcharts-scrollbar-thumb").attr({height:size-trackBorderWidth,width:size-trackBorderWidth,r:options.barBorderRadius||0}).add(scroller.scrollbarGroup);scroller.scrollbarRifles=renderer.path(Scrollbar.swapXY([["M",-3,size/4],["L",-3,2*size/3],["M",0,size/4],["L",0,2*size/3],["M",3,size/4],["L",3,2*size/3]],options.vertical)).addClass("highcharts-scrollbar-rifles").add(scroller.scrollbarGroup);if(!styledMode){scroller.scrollbar.attr({fill:options.barBackgroundColor,stroke:options.barBorderColor,"stroke-width":options.barBorderWidth});scroller.scrollbarRifles.attr({stroke:options.rifleColor,"stroke-width":1})}scroller.scrollbarStrokeWidth=scroller.scrollbar.strokeWidth();scroller.scrollbarGroup.translate(-crisp(0,scroller.scrollbarStrokeWidth),-crisp(0,scroller.scrollbarStrokeWidth));scroller.drawScrollbarButton(0);scroller.drawScrollbarButton(1)}setRange(from,to){const scroller=this,options=scroller.options,vertical=options.vertical,minWidth=options.minWidth,fullWidth=scroller.barWidth,method=this.rendered&&!this.hasDragged&&!(this.chart.navigator&&this.chart.navigator.hasDragged)?"animate":"attr";if(!Scrollbar_defined(fullWidth)){return}const toPX=fullWidth*Math.min(to,1);let fromPX,newSize;from=Math.max(from,0);fromPX=Math.ceil(fullWidth*from);scroller.calculatedWidth=newSize=Scrollbar_correctFloat(toPX-fromPX);if(newSize<minWidth){fromPX=(fullWidth-minWidth+newSize)*from;newSize=minWidth}const newPos=Math.floor(fromPX+scroller.xOffset+scroller.yOffset);const newRiflesPos=newSize/2-.5;scroller.from=from;scroller.to=to;if(!vertical){scroller.scrollbarGroup[method]({translateX:newPos});scroller.scrollbar[method]({width:newSize});scroller.scrollbarRifles[method]({translateX:newRiflesPos});scroller.scrollbarLeft=newPos;scroller.scrollbarTop=0}else{scroller.scrollbarGroup[method]({translateY:newPos});scroller.scrollbar[method]({height:newSize});scroller.scrollbarRifles[method]({translateY:newRiflesPos});scroller.scrollbarTop=newPos;scroller.scrollbarLeft=0}if(newSize<=12){scroller.scrollbarRifles.hide()}else{scroller.scrollbarRifles.show()}if(options.showFull===false){if(from<=0&&to>=1){scroller.group.hide()}else{scroller.group.show()}}scroller.rendered=true}shouldUpdateExtremes(eventType){return Scrollbar_pick(this.options.liveRedraw,highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().svg&&!highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().isTouchDevice&&!this.chart.boosted)||eventType==="mouseup"||eventType==="touchend"||!Scrollbar_defined(eventType)}trackClick(e){const scroller=this;const normalizedEvent=scroller.chart.pointer?.normalize(e)||e,range=scroller.to-scroller.from,top=scroller.y+scroller.scrollbarTop,left=scroller.x+scroller.scrollbarLeft;if(scroller.options.vertical&&normalizedEvent.chartY>top||!scroller.options.vertical&&normalizedEvent.chartX>left){scroller.updatePosition(scroller.from+range,scroller.to+range)}else{scroller.updatePosition(scroller.from-range,scroller.to-range)}fireEvent(scroller,"changed",{from:scroller.from,to:scroller.to,trigger:"scrollbar",DOMEvent:e})}update(options){this.destroy();this.init(this.chart.renderer,Scrollbar_merge(true,this.options,options),this.chart)}updatePosition(from,to){if(to>1){from=Scrollbar_correctFloat(1-Scrollbar_correctFloat(to-from));to=1}if(from<0){to=Scrollbar_correctFloat(to-from);from=0}this.from=from;this.to=to}}Scrollbar.defaultOptions=Scrollbar_ScrollbarDefaults;Scrollbar_defaultOptions.scrollbar=Scrollbar_merge(true,Scrollbar.defaultOptions,Scrollbar_defaultOptions.scrollbar);const Scrollbar_Scrollbar=Scrollbar;var highcharts_SVGRenderer_commonjs_highcharts_SVGRenderer_commonjs2_highcharts_SVGRenderer_root_Highcharts_SVGRenderer_=__webpack_require__(540);var highcharts_SVGRenderer_commonjs_highcharts_SVGRenderer_commonjs2_highcharts_SVGRenderer_root_Highcharts_SVGRenderer_default=__webpack_require__.n(highcharts_SVGRenderer_commonjs_highcharts_SVGRenderer_commonjs2_highcharts_SVGRenderer_root_Highcharts_SVGRenderer_);const{defaultOptions:Navigator_defaultOptions}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{isTouchDevice:Navigator_isTouchDevice}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{prototype:{symbols}}=highcharts_SVGRenderer_commonjs_highcharts_SVGRenderer_commonjs2_highcharts_SVGRenderer_root_Highcharts_SVGRenderer_default();const{addEvent:Navigator_addEvent,clamp,correctFloat:Navigator_correctFloat,defined:Navigator_defined,destroyObjectProperties:Navigator_destroyObjectProperties,erase,extend:Navigator_extend,find,fireEvent:Navigator_fireEvent,isArray:Navigator_isArray,isNumber:Navigator_isNumber,merge:Navigator_merge,pick:Navigator_pick,removeEvent:Navigator_removeEvent,splat:Navigator_splat}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function numExt(extreme,...args){const numbers=[].filter.call(args,Navigator_isNumber);if(numbers.length){return Math[extreme].apply(0,numbers)}}class Navigator{static compose(ChartClass,AxisClass,SeriesClass){Navigator_ChartNavigatorComposition.compose(ChartClass,Navigator);Navigator_NavigatorComposition.compose(ChartClass,AxisClass,SeriesClass)}constructor(chart){this.isDirty=false;this.scrollbarHeight=0;this.init(chart)}drawHandle(x,index,inverted,verb){const navigator=this,height=navigator.navigatorOptions.handles.height;navigator.handles[index][verb](inverted?{translateX:Math.round(navigator.left+navigator.height/2),translateY:Math.round(navigator.top+parseInt(x,10)+.5-height)}:{translateX:Math.round(navigator.left+parseInt(x,10)),translateY:Math.round(navigator.top+navigator.height/2-height/2-1)})}drawOutline(zoomedMin,zoomedMax,inverted,verb){const navigator=this,maskInside=navigator.navigatorOptions.maskInside,outlineWidth=navigator.outline.strokeWidth(),halfOutline=outlineWidth/2,outlineCorrection=outlineWidth%2/2,scrollButtonSize=navigator.scrollButtonSize,navigatorSize=navigator.size,navigatorTop=navigator.top,height=navigator.height,lineTop=navigatorTop-halfOutline,lineBtm=navigatorTop+height;let left=navigator.left,verticalMin,path;if(inverted){verticalMin=navigatorTop+zoomedMax+outlineCorrection;zoomedMax=navigatorTop+zoomedMin+outlineCorrection;path=[["M",left+height,navigatorTop-scrollButtonSize-outlineCorrection],["L",left+height,verticalMin],["L",left,verticalMin],["M",left,zoomedMax],["L",left+height,zoomedMax],["L",left+height,navigatorTop+navigatorSize+scrollButtonSize]];if(maskInside){path.push(["M",left+height,verticalMin-halfOutline],["L",left+height,zoomedMax+halfOutline])}}else{left-=scrollButtonSize;zoomedMin+=left+scrollButtonSize-outlineCorrection;zoomedMax+=left+scrollButtonSize-outlineCorrection;path=[["M",left,lineTop],["L",zoomedMin,lineTop],["L",zoomedMin,lineBtm],["M",zoomedMax,lineBtm],["L",zoomedMax,lineTop],["L",left+navigatorSize+scrollButtonSize*2,lineTop]];if(maskInside){path.push(["M",zoomedMin-halfOutline,lineTop],["L",zoomedMax+halfOutline,lineTop])}}navigator.outline[verb]({d:path})}drawMasks(zoomedMin,zoomedMax,inverted,verb){const navigator=this,left=navigator.left,top=navigator.top,navigatorHeight=navigator.height;let height,width,x,y;if(inverted){x=[left,left,left];y=[top,top+zoomedMin,top+zoomedMax];width=[navigatorHeight,navigatorHeight,navigatorHeight];height=[zoomedMin,zoomedMax-zoomedMin,navigator.size-zoomedMax]}else{x=[left,left+zoomedMin,left+zoomedMax];y=[top,top,top];width=[zoomedMin,zoomedMax-zoomedMin,navigator.size-zoomedMax];height=[navigatorHeight,navigatorHeight,navigatorHeight]}navigator.shades.forEach((shade,i)=>{shade[verb]({x:x[i],y:y[i],width:width[i],height:height[i]})})}renderElements(){const navigator=this,navigatorOptions=navigator.navigatorOptions,maskInside=navigatorOptions.maskInside,chart=navigator.chart,inverted=chart.inverted,renderer=chart.renderer,mouseCursor={cursor:inverted?"ns-resize":"ew-resize"},navigatorGroup=navigator.navigatorGroup??(navigator.navigatorGroup=renderer.g("navigator").attr({zIndex:8,visibility:"hidden"}).add());[!maskInside,maskInside,!maskInside].forEach((hasMask,index)=>{const shade=navigator.shades[index]??(navigator.shades[index]=renderer.rect().addClass("highcharts-navigator-mask"+(index===1?"-inside":"-outside")).add(navigatorGroup));if(!chart.styledMode){shade.attr({fill:hasMask?navigatorOptions.maskFill:"rgba(0,0,0,0)"});if(index===1){shade.css(mouseCursor)}}});if(!navigator.outline){navigator.outline=renderer.path().addClass("highcharts-navigator-outline").add(navigatorGroup)}if(!chart.styledMode){navigator.outline.attr({"stroke-width":navigatorOptions.outlineWidth,stroke:navigatorOptions.outlineColor})}if(navigatorOptions.handles?.enabled){const handlesOptions=navigatorOptions.handles,{height,width}=handlesOptions;[0,1].forEach(index=>{const symbolName=handlesOptions.symbols[index];if(!navigator.handles[index]||navigator.handles[index].symbolUrl!==symbolName){navigator.handles[index]?.destroy();navigator.handles[index]=renderer.symbol(symbolName,-width/2-1,0,width,height,handlesOptions);navigator.handles[index].attr({zIndex:7-index}).addClass("highcharts-navigator-handle "+"highcharts-navigator-handle-"+["left","right"][index]).add(navigatorGroup);navigator.addMouseEvents()}else if(!navigator.handles[index].isImg&&navigator.handles[index].symbolName!==symbolName){const symbolFn=symbols[symbolName],path=symbolFn.call(symbols,-width/2-1,0,width,height);navigator.handles[index].attr({d:path});navigator.handles[index].symbolName=symbolName}if(chart.inverted){navigator.handles[index].attr({rotation:90,rotationOriginX:Math.floor(-width/2),rotationOriginY:(height+width)/2})}if(!chart.styledMode){navigator.handles[index].attr({fill:handlesOptions.backgroundColor,stroke:handlesOptions.borderColor,"stroke-width":handlesOptions.lineWidth,width:handlesOptions.width,height:handlesOptions.height,x:-width/2-1,y:0}).css(mouseCursor)}})}}update(options,redraw=false){const chart=this.chart,invertedUpdate=chart.options.chart.inverted!==chart.scrollbar?.options.vertical;Navigator_merge(true,chart.options.navigator,options);this.navigatorOptions=chart.options.navigator||{};this.setOpposite();if(Navigator_defined(options.enabled)||invertedUpdate){this.destroy();this.navigatorEnabled=options.enabled||this.navigatorEnabled;return this.init(chart)}if(this.navigatorEnabled){this.isDirty=true;if(options.adaptToUpdatedData===false){this.baseSeries.forEach(series=>{Navigator_removeEvent(series,"updatedData",this.updatedDataHandler)},this)}if(options.adaptToUpdatedData){this.baseSeries.forEach(series=>{series.eventsToUnbind.push(Navigator_addEvent(series,"updatedData",this.updatedDataHandler))},this)}if(options.series||options.baseSeries){this.setBaseSeries(void 0,false)}if(options.height||options.xAxis||options.yAxis){this.height=options.height??this.height;const offsets=this.getXAxisOffsets();this.xAxis.update({...options.xAxis,offsets:offsets,[chart.inverted?"width":"height"]:this.height,[chart.inverted?"height":"width"]:void 0},false);this.yAxis.update({...options.yAxis,[chart.inverted?"width":"height"]:this.height},false)}}if(redraw){chart.redraw()}}render(min,max,pxMin,pxMax){const navigator=this,chart=navigator.chart,xAxis=navigator.xAxis,pointRange=xAxis.pointRange||0,scrollbarXAxis=xAxis.navigatorAxis.fake?chart.xAxis[0]:xAxis,navigatorEnabled=navigator.navigatorEnabled,rendered=navigator.rendered,inverted=chart.inverted,minRange=chart.xAxis[0].minRange,maxRange=chart.xAxis[0].options.maxRange,scrollButtonSize=navigator.scrollButtonSize;let navigatorWidth,scrollbarLeft,scrollbarTop,scrollbarHeight=navigator.scrollbarHeight,navigatorSize,verb;if(this.hasDragged&&!Navigator_defined(pxMin)){return}if(this.isDirty){this.renderElements()}min=Navigator_correctFloat(min-pointRange/2);max=Navigator_correctFloat(max+pointRange/2);if(!Navigator_isNumber(min)||!Navigator_isNumber(max)){if(rendered){pxMin=0;pxMax=Navigator_pick(xAxis.width,scrollbarXAxis.width)}else{return}}navigator.left=Navigator_pick(xAxis.left,chart.plotLeft+scrollButtonSize+(inverted?chart.plotWidth:0));let zoomedMax=navigator.size=navigatorSize=Navigator_pick(xAxis.len,(inverted?chart.plotHeight:chart.plotWidth)-2*scrollButtonSize);if(inverted){navigatorWidth=scrollbarHeight}else{navigatorWidth=navigatorSize+2*scrollButtonSize}pxMin=Navigator_pick(pxMin,xAxis.toPixels(min,true));pxMax=Navigator_pick(pxMax,xAxis.toPixels(max,true));if(!Navigator_isNumber(pxMin)||Math.abs(pxMin)===Infinity){pxMin=0;pxMax=navigatorWidth}const newMin=xAxis.toValue(pxMin,true),newMax=xAxis.toValue(pxMax,true),currentRange=Math.abs(Navigator_correctFloat(newMax-newMin));if(currentRange<minRange){if(this.grabbedLeft){pxMin=xAxis.toPixels(newMax-minRange-pointRange,true)}else if(this.grabbedRight){pxMax=xAxis.toPixels(newMin+minRange+pointRange,true)}}else if(Navigator_defined(maxRange)&&Navigator_correctFloat(currentRange-pointRange)>maxRange){if(this.grabbedLeft){pxMin=xAxis.toPixels(newMax-maxRange-pointRange,true)}else if(this.grabbedRight){pxMax=xAxis.toPixels(newMin+maxRange+pointRange,true)}}navigator.zoomedMax=clamp(Math.max(pxMin,pxMax),0,zoomedMax);navigator.zoomedMin=clamp(navigator.fixedWidth?navigator.zoomedMax-navigator.fixedWidth:Math.min(pxMin,pxMax),0,zoomedMax);navigator.range=navigator.zoomedMax-navigator.zoomedMin;zoomedMax=Math.round(navigator.zoomedMax);const zoomedMin=Math.round(navigator.zoomedMin);if(navigatorEnabled){navigator.navigatorGroup.attr({visibility:"inherit"});verb=rendered&&!navigator.hasDragged?"animate":"attr";navigator.drawMasks(zoomedMin,zoomedMax,inverted,verb);navigator.drawOutline(zoomedMin,zoomedMax,inverted,verb);if(navigator.navigatorOptions.handles.enabled){navigator.drawHandle(zoomedMin,0,inverted,verb);navigator.drawHandle(zoomedMax,1,inverted,verb)}}if(navigator.scrollbar){if(inverted){scrollbarTop=navigator.top-scrollButtonSize;scrollbarLeft=navigator.left-scrollbarHeight+(navigatorEnabled||!scrollbarXAxis.opposite?0:(scrollbarXAxis.titleOffset||0)+scrollbarXAxis.axisTitleMargin);scrollbarHeight=navigatorSize+2*scrollButtonSize}else{scrollbarTop=navigator.top+(navigatorEnabled?navigator.height:-scrollbarHeight);scrollbarLeft=navigator.left-scrollButtonSize}navigator.scrollbar.position(scrollbarLeft,scrollbarTop,navigatorWidth,scrollbarHeight);navigator.scrollbar.setRange(navigator.zoomedMin/(navigatorSize||1),navigator.zoomedMax/(navigatorSize||1))}navigator.rendered=true;this.isDirty=false;Navigator_fireEvent(this,"afterRender")}addMouseEvents(){const navigator=this,chart=navigator.chart,container=chart.container;let eventsToUnbind=[],mouseMoveHandler,mouseUpHandler;navigator.mouseMoveHandler=mouseMoveHandler=function(e){navigator.onMouseMove(e)};navigator.mouseUpHandler=mouseUpHandler=function(e){navigator.onMouseUp(e)};eventsToUnbind=navigator.getPartsEvents("mousedown");eventsToUnbind.push(Navigator_addEvent(chart.renderTo,"mousemove",mouseMoveHandler),Navigator_addEvent(container.ownerDocument,"mouseup",mouseUpHandler),Navigator_addEvent(chart.renderTo,"touchmove",mouseMoveHandler),Navigator_addEvent(container.ownerDocument,"touchend",mouseUpHandler));eventsToUnbind.concat(navigator.getPartsEvents("touchstart"));navigator.eventsToUnbind=eventsToUnbind;if(navigator.series&&navigator.series[0]){eventsToUnbind.push(Navigator_addEvent(navigator.series[0].xAxis,"foundExtremes",function(){chart.navigator.modifyNavigatorAxisExtremes()}))}}getPartsEvents(eventName){const navigator=this,events=[];["shades","handles"].forEach(function(name){navigator[name].forEach(function(navigatorItem,index){events.push(Navigator_addEvent(navigatorItem.element,eventName,function(e){navigator[name+"Mousedown"](e,index)}))})});return events}shadesMousedown(e,index){e=this.chart.pointer?.normalize(e)||e;const navigator=this,chart=navigator.chart,xAxis=navigator.xAxis,zoomedMin=navigator.zoomedMin,navigatorSize=navigator.size,range=navigator.range;let navigatorPosition=navigator.left,chartX=e.chartX,fixedMax,fixedMin,ext,left;if(chart.inverted){chartX=e.chartY;navigatorPosition=navigator.top}if(index===1){navigator.grabbedCenter=chartX;navigator.fixedWidth=range;navigator.dragOffset=chartX-zoomedMin}else{left=chartX-navigatorPosition-range/2;if(index===0){left=Math.max(0,left)}else if(index===2&&left+range>=navigatorSize){left=navigatorSize-range;if(navigator.reversedExtremes){left-=range;fixedMin=navigator.getUnionExtremes().dataMin}else{fixedMax=navigator.getUnionExtremes().dataMax}}if(left!==zoomedMin){navigator.fixedWidth=range;ext=xAxis.navigatorAxis.toFixedRange(left,left+range,fixedMin,fixedMax);if(Navigator_defined(ext.min)){Navigator_fireEvent(this,"setRange",{min:Math.min(ext.min,ext.max),max:Math.max(ext.min,ext.max),redraw:true,eventArguments:{trigger:"navigator"}})}}}}handlesMousedown(e,index){e=this.chart.pointer?.normalize(e)||e;const navigator=this,chart=navigator.chart,baseXAxis=chart.xAxis[0],reverse=navigator.reversedExtremes;if(index===0){navigator.grabbedLeft=true;navigator.otherHandlePos=navigator.zoomedMax;navigator.fixedExtreme=reverse?baseXAxis.min:baseXAxis.max}else{navigator.grabbedRight=true;navigator.otherHandlePos=navigator.zoomedMin;navigator.fixedExtreme=reverse?baseXAxis.max:baseXAxis.min}chart.setFixedRange(void 0)}onMouseMove(e){const navigator=this,chart=navigator.chart,navigatorSize=navigator.navigatorSize,range=navigator.range,dragOffset=navigator.dragOffset,inverted=chart.inverted;let left=navigator.left,chartX;if(!e.touches||e.touches[0].pageX!==0){e=chart.pointer?.normalize(e)||e;chartX=e.chartX;if(inverted){left=navigator.top;chartX=e.chartY}if(navigator.grabbedLeft){navigator.hasDragged=true;navigator.render(0,0,chartX-left,navigator.otherHandlePos)}else if(navigator.grabbedRight){navigator.hasDragged=true;navigator.render(0,0,navigator.otherHandlePos,chartX-left)}else if(navigator.grabbedCenter){navigator.hasDragged=true;if(chartX<dragOffset){chartX=dragOffset}else if(chartX>navigatorSize+dragOffset-range){chartX=navigatorSize+dragOffset-range}navigator.render(0,0,chartX-dragOffset,chartX-dragOffset+range)}if(navigator.hasDragged&&navigator.scrollbar&&Navigator_pick(navigator.scrollbar.options.liveRedraw,!Navigator_isTouchDevice&&!this.chart.boosted)){e.DOMType=e.type;setTimeout(function(){navigator.onMouseUp(e)},0)}}}onMouseUp(e){const navigator=this,chart=navigator.chart,xAxis=navigator.xAxis,scrollbar=navigator.scrollbar,DOMEvent=e.DOMEvent||e,inverted=chart.inverted,verb=navigator.rendered&&!navigator.hasDragged?"animate":"attr";let zoomedMax,zoomedMin,unionExtremes,fixedMin,fixedMax,ext;if(navigator.hasDragged&&(!scrollbar||!scrollbar.hasDragged)||e.trigger==="scrollbar"){unionExtremes=navigator.getUnionExtremes();if(navigator.zoomedMin===navigator.otherHandlePos){fixedMin=navigator.fixedExtreme}else if(navigator.zoomedMax===navigator.otherHandlePos){fixedMax=navigator.fixedExtreme}if(navigator.zoomedMax===navigator.size){fixedMax=navigator.reversedExtremes?unionExtremes.dataMin:unionExtremes.dataMax}if(navigator.zoomedMin===0){fixedMin=navigator.reversedExtremes?unionExtremes.dataMax:unionExtremes.dataMin}ext=xAxis.navigatorAxis.toFixedRange(navigator.zoomedMin,navigator.zoomedMax,fixedMin,fixedMax);if(Navigator_defined(ext.min)){Navigator_fireEvent(this,"setRange",{min:Math.min(ext.min,ext.max),max:Math.max(ext.min,ext.max),redraw:true,animation:navigator.hasDragged?false:null,eventArguments:{trigger:"navigator",triggerOp:"navigator-drag",DOMEvent:DOMEvent}})}}if(e.DOMType!=="mousemove"&&e.DOMType!=="touchmove"){navigator.grabbedLeft=navigator.grabbedRight=navigator.grabbedCenter=navigator.fixedWidth=navigator.fixedExtreme=navigator.otherHandlePos=navigator.hasDragged=navigator.dragOffset=null}if(navigator.navigatorEnabled&&Navigator_isNumber(navigator.zoomedMin)&&Navigator_isNumber(navigator.zoomedMax)){zoomedMin=Math.round(navigator.zoomedMin);zoomedMax=Math.round(navigator.zoomedMax);if(navigator.shades){navigator.drawMasks(zoomedMin,zoomedMax,inverted,verb)}if(navigator.outline){navigator.drawOutline(zoomedMin,zoomedMax,inverted,verb)}if(navigator.navigatorOptions.handles.enabled&&Object.keys(navigator.handles).length===navigator.handles.length){navigator.drawHandle(zoomedMin,0,inverted,verb);navigator.drawHandle(zoomedMax,1,inverted,verb)}}}removeEvents(){if(this.eventsToUnbind){this.eventsToUnbind.forEach(function(unbind){unbind()});this.eventsToUnbind=void 0}this.removeBaseSeriesEvents()}removeBaseSeriesEvents(){const baseSeries=this.baseSeries||[];if(this.navigatorEnabled&&baseSeries[0]){if(this.navigatorOptions.adaptToUpdatedData!==false){baseSeries.forEach(function(series){Navigator_removeEvent(series,"updatedData",this.updatedDataHandler)},this)}if(baseSeries[0].xAxis){Navigator_removeEvent(baseSeries[0].xAxis,"foundExtremes",this.modifyBaseAxisExtremes)}}}getXAxisOffsets(){return this.chart.inverted?[this.scrollButtonSize,0,-this.scrollButtonSize,0]:[0,-this.scrollButtonSize,0,this.scrollButtonSize]}init(chart){const chartOptions=chart.options,navigatorOptions=chartOptions.navigator||{},navigatorEnabled=navigatorOptions.enabled,scrollbarOptions=chartOptions.scrollbar||{},scrollbarEnabled=scrollbarOptions.enabled,height=navigatorEnabled&&navigatorOptions.height||0,scrollbarHeight=scrollbarEnabled&&scrollbarOptions.height||0,scrollButtonSize=scrollbarOptions.buttonsEnabled&&scrollbarHeight||0;this.handles=[];this.shades=[];this.chart=chart;this.setBaseSeries();this.height=height;this.scrollbarHeight=scrollbarHeight;this.scrollButtonSize=scrollButtonSize;this.scrollbarEnabled=scrollbarEnabled;this.navigatorEnabled=navigatorEnabled;this.navigatorOptions=navigatorOptions;this.scrollbarOptions=scrollbarOptions;this.setOpposite();const navigator=this,baseSeries=navigator.baseSeries,xAxisIndex=chart.xAxis.length,yAxisIndex=chart.yAxis.length,baseXaxis=baseSeries&&baseSeries[0]&&baseSeries[0].xAxis||chart.xAxis[0]||{options:{}};chart.isDirtyBox=true;if(navigator.navigatorEnabled){const offsets=this.getXAxisOffsets();navigator.xAxis=new(highcharts_Axis_commonjs_highcharts_Axis_commonjs2_highcharts_Axis_root_Highcharts_Axis_default())(chart,Navigator_merge({breaks:baseXaxis.options.breaks,ordinal:baseXaxis.options.ordinal,overscroll:baseXaxis.options.overscroll},navigatorOptions.xAxis,{type:"datetime",yAxis:navigatorOptions.yAxis?.id,index:xAxisIndex,isInternal:true,offset:0,keepOrdinalPadding:true,startOnTick:false,endOnTick:false,minPadding:baseXaxis.options.ordinal?0:baseXaxis.options.minPadding,maxPadding:baseXaxis.options.ordinal?0:baseXaxis.options.maxPadding,zoomEnabled:false},chart.inverted?{offsets:offsets,width:height}:{offsets:offsets,height:height}),"xAxis");navigator.yAxis=new(highcharts_Axis_commonjs_highcharts_Axis_commonjs2_highcharts_Axis_root_Highcharts_Axis_default())(chart,Navigator_merge(navigatorOptions.yAxis,{alignTicks:false,offset:0,index:yAxisIndex,isInternal:true,reversed:Navigator_pick(navigatorOptions.yAxis&&navigatorOptions.yAxis.reversed,chart.yAxis[0]&&chart.yAxis[0].reversed,false),zoomEnabled:false},chart.inverted?{width:height}:{height:height}),"yAxis");if(baseSeries||navigatorOptions.series.data){navigator.updateNavigatorSeries(false)}else if(chart.series.length===0){navigator.unbindRedraw=Navigator_addEvent(chart,"beforeRedraw",function(){if(chart.series.length>0&&!navigator.series){navigator.setBaseSeries();navigator.unbindRedraw()}})}navigator.reversedExtremes=chart.inverted&&!navigator.xAxis.reversed||!chart.inverted&&navigator.xAxis.reversed;navigator.renderElements();navigator.addMouseEvents()}else{navigator.xAxis={chart:chart,navigatorAxis:{fake:true},translate:function(value,reverse){const axis=chart.xAxis[0],ext=axis.getExtremes(),scrollTrackWidth=axis.len-2*scrollButtonSize,min=numExt("min",axis.options.min,ext.dataMin),valueRange=numExt("max",axis.options.max,ext.dataMax)-min;return reverse?value*valueRange/scrollTrackWidth+min:scrollTrackWidth*(value-min)/valueRange},toPixels:function(value){return this.translate(value)},toValue:function(value){return this.translate(value,true)}};navigator.xAxis.navigatorAxis.axis=navigator.xAxis;navigator.xAxis.navigatorAxis.toFixedRange=NavigatorAxisComposition.prototype.toFixedRange.bind(navigator.xAxis.navigatorAxis)}if(chart.options.scrollbar.enabled){const options=Navigator_merge(chart.options.scrollbar,{vertical:chart.inverted});if(!Navigator_isNumber(options.margin)&&navigator.navigatorEnabled){options.margin=chart.inverted?-3:3}chart.scrollbar=navigator.scrollbar=new Scrollbar_Scrollbar(chart.renderer,options,chart);Navigator_addEvent(navigator.scrollbar,"changed",function(e){const range=navigator.size,to=range*this.to,from=range*this.from;navigator.hasDragged=navigator.scrollbar.hasDragged;navigator.render(0,0,from,to);if(this.shouldUpdateExtremes(e.DOMType)){setTimeout(function(){navigator.onMouseUp(e)})}})}navigator.addBaseSeriesEvents();navigator.addChartEvents()}setOpposite(){const navigatorOptions=this.navigatorOptions,navigatorEnabled=this.navigatorEnabled,chart=this.chart;this.opposite=Navigator_pick(navigatorOptions.opposite,Boolean(!navigatorEnabled&&chart.inverted))}getUnionExtremes(returnFalseOnNoBaseSeries){const baseAxis=this.chart.xAxis[0],time=this.chart.time,navAxis=this.xAxis,navAxisOptions=navAxis.options,baseAxisOptions=baseAxis.options;let ret;if(!returnFalseOnNoBaseSeries||baseAxis.dataMin!==null){ret={dataMin:Navigator_pick(time.parse(navAxisOptions?.min),numExt("min",time.parse(baseAxisOptions.min),baseAxis.dataMin,navAxis.dataMin,navAxis.min)),dataMax:Navigator_pick(time.parse(navAxisOptions?.max),numExt("max",time.parse(baseAxisOptions.max),baseAxis.dataMax,navAxis.dataMax,navAxis.max))}}return ret}setBaseSeries(baseSeriesOptions,redraw){const chart=this.chart,baseSeries=this.baseSeries=[];baseSeriesOptions=baseSeriesOptions||chart.options&&chart.options.navigator.baseSeries||(chart.series.length?find(chart.series,s=>!s.options.isInternal).index:0);(chart.series||[]).forEach((series,i)=>{if(!series.options.isInternal&&(series.options.showInNavigator||(i===baseSeriesOptions||series.options.id===baseSeriesOptions)&&series.options.showInNavigator!==false)){baseSeries.push(series)}});if(this.xAxis&&!this.xAxis.navigatorAxis.fake){this.updateNavigatorSeries(true,redraw)}}updateNavigatorSeries(addEvents,redraw){const navigator=this,chart=navigator.chart,baseSeries=navigator.baseSeries,navSeriesMixin={enableMouseTracking:false,index:null,linkedTo:null,group:"nav",padXAxis:false,xAxis:this.navigatorOptions.xAxis?.id,yAxis:this.navigatorOptions.yAxis?.id,showInLegend:false,stacking:void 0,isInternal:true,states:{inactive:{opacity:1}}},navigatorSeries=navigator.series=(navigator.series||[]).filter(navSeries=>{const base=navSeries.baseSeries;if(baseSeries.indexOf(base)<0){if(base){Navigator_removeEvent(base,"updatedData",navigator.updatedDataHandler);delete base.navigatorSeries}if(navSeries.chart){navSeries.destroy()}return false}return true});let baseOptions,mergedNavSeriesOptions,chartNavigatorSeriesOptions=navigator.navigatorOptions.series,baseNavigatorOptions;if(baseSeries&&baseSeries.length){baseSeries.forEach(base=>{const linkedNavSeries=base.navigatorSeries,userNavOptions=Navigator_extend({color:base.color,visible:base.visible},!Navigator_isArray(chartNavigatorSeriesOptions)?chartNavigatorSeriesOptions:Navigator_defaultOptions.navigator.series);if(linkedNavSeries&&navigator.navigatorOptions.adaptToUpdatedData===false){return}navSeriesMixin.name="Navigator "+baseSeries.length;baseOptions=base.options||{};baseNavigatorOptions=baseOptions.navigatorOptions||{};userNavOptions.dataLabels=Navigator_splat(userNavOptions.dataLabels);mergedNavSeriesOptions=Navigator_merge(baseOptions,navSeriesMixin,userNavOptions,baseNavigatorOptions);mergedNavSeriesOptions.pointRange=Navigator_pick(userNavOptions.pointRange,baseNavigatorOptions.pointRange,Navigator_defaultOptions.plotOptions[mergedNavSeriesOptions.type||"line"].pointRange);const navigatorSeriesData=baseNavigatorOptions.data||userNavOptions.data;navigator.hasNavigatorData=navigator.hasNavigatorData||!!navigatorSeriesData;mergedNavSeriesOptions.data=navigatorSeriesData||baseOptions.data?.slice(0);if(linkedNavSeries&&linkedNavSeries.options){linkedNavSeries.update(mergedNavSeriesOptions,redraw)}else{base.navigatorSeries=chart.initSeries(mergedNavSeriesOptions);chart.setSortedData();base.navigatorSeries.baseSeries=base;navigatorSeries.push(base.navigatorSeries)}})}if(chartNavigatorSeriesOptions.data&&!(baseSeries&&baseSeries.length)||Navigator_isArray(chartNavigatorSeriesOptions)){navigator.hasNavigatorData=false;chartNavigatorSeriesOptions=Navigator_splat(chartNavigatorSeriesOptions);chartNavigatorSeriesOptions.forEach((userSeriesOptions,i)=>{navSeriesMixin.name="Navigator "+(navigatorSeries.length+1);mergedNavSeriesOptions=Navigator_merge(Navigator_defaultOptions.navigator.series,{color:chart.series[i]&&!chart.series[i].options.isInternal&&chart.series[i].color||chart.options.colors[i]||chart.options.colors[0]},navSeriesMixin,userSeriesOptions);mergedNavSeriesOptions.data=userSeriesOptions.data;if(mergedNavSeriesOptions.data){navigator.hasNavigatorData=true;navigatorSeries.push(chart.initSeries(mergedNavSeriesOptions))}})}if(addEvents){this.addBaseSeriesEvents()}}addBaseSeriesEvents(){const navigator=this,baseSeries=navigator.baseSeries||[];if(baseSeries[0]&&baseSeries[0].xAxis){baseSeries[0].eventsToUnbind.push(Navigator_addEvent(baseSeries[0].xAxis,"foundExtremes",this.modifyBaseAxisExtremes))}baseSeries.forEach(base=>{base.eventsToUnbind.push(Navigator_addEvent(base,"show",function(){if(this.navigatorSeries){this.navigatorSeries.setVisible(true,false)}}));base.eventsToUnbind.push(Navigator_addEvent(base,"hide",function(){if(this.navigatorSeries){this.navigatorSeries.setVisible(false,false)}}));if(this.navigatorOptions.adaptToUpdatedData!==false){if(base.xAxis){base.eventsToUnbind.push(Navigator_addEvent(base,"updatedData",this.updatedDataHandler))}}base.eventsToUnbind.push(Navigator_addEvent(base,"remove",function(){if(baseSeries){erase(baseSeries,base)}if(this.navigatorSeries&&navigator.series){erase(navigator.series,this.navigatorSeries);if(Navigator_defined(this.navigatorSeries.options)){this.navigatorSeries.remove(false)}delete this.navigatorSeries}}))})}getBaseSeriesMin(currentSeriesMin){return this.baseSeries.reduce(function(min,series){return Math.min(min,series.getColumn("x")[0]??min)},currentSeriesMin)}modifyNavigatorAxisExtremes(){const xAxis=this.xAxis;if(typeof xAxis.getExtremes!=="undefined"){const unionExtremes=this.getUnionExtremes(true);if(unionExtremes&&(unionExtremes.dataMin!==xAxis.min||unionExtremes.dataMax!==xAxis.max)){xAxis.min=unionExtremes.dataMin;xAxis.max=unionExtremes.dataMax}}}modifyBaseAxisExtremes(){const baseXAxis=this,navigator=baseXAxis.chart.navigator,baseExtremes=baseXAxis.getExtremes(),baseMin=baseExtremes.min,baseMax=baseExtremes.max,baseDataMin=baseExtremes.dataMin,baseDataMax=baseExtremes.dataMax,range=baseMax-baseMin,stickToMin=navigator.stickToMin,stickToMax=navigator.stickToMax,overscroll=Navigator_pick(baseXAxis.ordinal?.convertOverscroll(baseXAxis.options.overscroll),0),navigatorSeries=navigator.series&&navigator.series[0],hasSetExtremes=!!baseXAxis.setExtremes,unmutable=baseXAxis.eventArgs&&baseXAxis.eventArgs.trigger==="rangeSelectorButton";let newMax,newMin;if(!unmutable){if(stickToMin){newMin=baseDataMin;newMax=newMin+range}if(stickToMax){newMax=baseDataMax+overscroll;if(!stickToMin){newMin=Math.max(baseDataMin,newMax-range,navigator.getBaseSeriesMin(navigatorSeries&&navigatorSeries.xData?navigatorSeries.xData[0]:-Number.MAX_VALUE))}}if(hasSetExtremes&&(stickToMin||stickToMax)){if(Navigator_isNumber(newMin)){baseXAxis.min=baseXAxis.userMin=newMin;baseXAxis.max=baseXAxis.userMax=newMax}}}navigator.stickToMin=navigator.stickToMax=null}updatedDataHandler(){const navigator=this.chart.navigator,baseSeries=this,navigatorSeries=this.navigatorSeries,shouldStickToMax=navigator.reversedExtremes?Math.round(navigator.zoomedMin)===0:Math.round(navigator.zoomedMax)>=Math.round(navigator.size);navigator.stickToMax=Navigator_pick(this.chart.options.navigator&&this.chart.options.navigator.stickToMax,shouldStickToMax);navigator.stickToMin=navigator.shouldStickToMin(baseSeries,navigator);if(navigatorSeries&&!navigator.hasNavigatorData){navigatorSeries.options.pointStart=baseSeries.getColumn("x")[0];navigatorSeries.setData(baseSeries.options.data,false,null,false)}}shouldStickToMin(baseSeries,navigator){const xDataMin=navigator.getBaseSeriesMin(baseSeries.getColumn("x")[0]),xAxis=baseSeries.xAxis,max=xAxis.max,min=xAxis.min,range=xAxis.options.range;let stickToMin=true;if(Navigator_isNumber(max)&&Navigator_isNumber(min)){if(range&&max-xDataMin>0){stickToMin=max-xDataMin<range}else{stickToMin=min<=xDataMin}}else{stickToMin=false}return stickToMin}addChartEvents(){if(!this.eventsToUnbind){this.eventsToUnbind=[]}this.eventsToUnbind.push(Navigator_addEvent(this.chart,"redraw",function(){const navigator=this.navigator,xAxis=navigator&&(navigator.baseSeries&&navigator.baseSeries[0]&&navigator.baseSeries[0].xAxis||this.xAxis[0]);if(xAxis){navigator.render(xAxis.min,xAxis.max)}}),Navigator_addEvent(this.chart,"getMargins",function(){const chart=this,navigator=chart.navigator;let marginName=navigator.opposite?"plotTop":"marginBottom";if(chart.inverted){marginName=navigator.opposite?"marginRight":"plotLeft"}chart[marginName]=(chart[marginName]||0)+(navigator.navigatorEnabled||!chart.inverted?navigator.height+navigator.scrollbarHeight:0)+navigator.navigatorOptions.margin}),Navigator_addEvent(Navigator,"setRange",function(e){this.chart.xAxis[0].setExtremes(e.min,e.max,e.redraw,e.animation,e.eventArguments)}))}destroy(){this.removeEvents();if(this.xAxis){erase(this.chart.xAxis,this.xAxis);erase(this.chart.axes,this.xAxis)}if(this.yAxis){erase(this.chart.yAxis,this.yAxis);erase(this.chart.axes,this.yAxis)}(this.series||[]).forEach(s=>{if(s.destroy){s.destroy()}});["series","xAxis","yAxis","shades","outline","scrollbarTrack","scrollbarRifles","scrollbarGroup","scrollbar","navigatorGroup","rendered"].forEach(prop=>{if(this[prop]&&this[prop].destroy){this[prop].destroy()}this[prop]=null});[this.handles].forEach(coll=>{Navigator_destroyObjectProperties(coll)});this.navigatorEnabled=false}}const Navigator_Navigator=Navigator;const lang={rangeSelectorZoom:"Zoom",rangeSelectorFrom:"",rangeSelectorTo:""};const rangeSelector={allButtonsEnabled:false,buttons:[{type:"month",count:1,text:"1m",title:"View 1 month"},{type:"month",count:3,text:"3m",title:"View 3 months"},{type:"month",count:6,text:"6m",title:"View 6 months"},{type:"ytd",text:"YTD",title:"View year to date"},{type:"year",count:1,text:"1y",title:"View 1 year"},{type:"all",text:"All",title:"View all"}],buttonSpacing:5,dropdown:"responsive",enabled:void 0,verticalAlign:"top",buttonTheme:{width:28,height:18,padding:2,zIndex:7},floating:false,x:0,y:0,height:void 0,inputBoxBorderColor:"none",inputBoxHeight:17,inputBoxWidth:void 0,inputDateFormat:"%[ebY]",inputDateParser:void 0,inputEditDateFormat:"%Y-%m-%d",inputEnabled:true,inputPosition:{align:"right",x:0,y:0},inputSpacing:5,selected:void 0,buttonPosition:{align:"left",x:0,y:0},inputStyle:{color:"#334eff",cursor:"pointer",fontSize:"0.8em"},labelStyle:{color:"#666666",fontSize:"0.8em"}};const RangeSelectorDefaults={lang:lang,rangeSelector:rangeSelector};const RangeSelector_RangeSelectorDefaults=RangeSelectorDefaults;const{defaultOptions:RangeSelectorComposition_defaultOptions}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{composed:RangeSelectorComposition_composed}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{addEvent:RangeSelectorComposition_addEvent,defined:RangeSelectorComposition_defined,extend:RangeSelectorComposition_extend,isNumber:RangeSelectorComposition_isNumber,merge:RangeSelectorComposition_merge,pick:RangeSelectorComposition_pick,pushUnique:RangeSelectorComposition_pushUnique}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const chartDestroyEvents=[];let RangeSelectorConstructor;function axisMinFromRange(){const rangeOptions=this.range,type=rangeOptions.type,max=this.max,time=this.chart.time,getTrueRange=function(base,count){const original=time.toParts(base),modified=original.slice();if(type==="year"){modified[0]+=count}else{modified[1]+=count}let d=time.makeTime.apply(time,modified);const numbers=time.toParts(d);if(type==="month"&&original[1]===numbers[1]&&Math.abs(count)===1){modified[0]=original[0];modified[1]=original[1];modified[2]=0}d=time.makeTime.apply(time,modified);return d-base};let min,range;if(RangeSelectorComposition_isNumber(rangeOptions)){min=max-rangeOptions;range=rangeOptions}else if(rangeOptions){min=max+getTrueRange(max,-(rangeOptions.count||1));if(this.chart){this.chart.setFixedRange(max-min)}}const dataMin=RangeSelectorComposition_pick(this.dataMin,Number.MIN_VALUE);if(!RangeSelectorComposition_isNumber(min)){min=dataMin}if(min<=dataMin){min=dataMin;if(typeof range==="undefined"){range=getTrueRange(min,rangeOptions.count)}this.newMax=Math.min(min+range,RangeSelectorComposition_pick(this.dataMax,Number.MAX_VALUE))}if(!RangeSelectorComposition_isNumber(max)){min=void 0}else if(!RangeSelectorComposition_isNumber(rangeOptions)&&rangeOptions&&rangeOptions._offsetMin){min+=rangeOptions._offsetMin}return min}function updateRangeSelectorButtons(){this.rangeSelector?.redrawElements()}function RangeSelectorComposition_compose(AxisClass,ChartClass,RangeSelectorClass){RangeSelectorConstructor=RangeSelectorClass;if(RangeSelectorComposition_pushUnique(RangeSelectorComposition_composed,"RangeSelector")){const chartProto=ChartClass.prototype;AxisClass.prototype.minFromRange=axisMinFromRange;RangeSelectorComposition_addEvent(ChartClass,"afterGetContainer",createRangeSelector);RangeSelectorComposition_addEvent(ChartClass,"beforeRender",RangeSelectorComposition_onChartBeforeRender);RangeSelectorComposition_addEvent(ChartClass,"destroy",onChartDestroy);RangeSelectorComposition_addEvent(ChartClass,"getMargins",onChartGetMargins);RangeSelectorComposition_addEvent(ChartClass,"redraw",redrawRangeSelector);RangeSelectorComposition_addEvent(ChartClass,"update",RangeSelectorComposition_onChartUpdate);RangeSelectorComposition_addEvent(ChartClass,"beforeRedraw",updateRangeSelectorButtons);chartProto.callbacks.push(redrawRangeSelector);RangeSelectorComposition_extend(RangeSelectorComposition_defaultOptions,{rangeSelector:RangeSelector_RangeSelectorDefaults.rangeSelector});RangeSelectorComposition_extend(RangeSelectorComposition_defaultOptions.lang,RangeSelector_RangeSelectorDefaults.lang)}}function createRangeSelector(){if(this.options.rangeSelector&&this.options.rangeSelector.enabled){this.rangeSelector=new RangeSelectorConstructor(this)}}function RangeSelectorComposition_onChartBeforeRender(){const chart=this,rangeSelector=chart.rangeSelector;if(rangeSelector){if(RangeSelectorComposition_isNumber(rangeSelector.deferredYTDClick)){rangeSelector.clickButton(rangeSelector.deferredYTDClick);delete rangeSelector.deferredYTDClick}const verticalAlign=rangeSelector.options.verticalAlign;if(!rangeSelector.options.floating){if(verticalAlign==="bottom"){this.extraBottomMargin=true}else if(verticalAlign==="top"){this.extraTopMargin=true}}}}function redrawRangeSelector(){const chart=this;const rangeSelector=this.rangeSelector;if(!rangeSelector){return}let alignTo;const extremes=chart.xAxis[0].getExtremes();const legend=chart.legend;const verticalAlign=rangeSelector&&rangeSelector.options.verticalAlign;if(RangeSelectorComposition_isNumber(extremes.min)){rangeSelector.render(extremes.min,extremes.max)}if(legend.display&&verticalAlign==="top"&&verticalAlign===legend.options.verticalAlign){alignTo=RangeSelectorComposition_merge(chart.spacingBox);if(legend.options.layout==="vertical"){alignTo.y=chart.plotTop}else{alignTo.y+=rangeSelector.getHeight()}legend.group.placed=false;legend.align(alignTo)}}function onChartDestroy(){for(let i=0,iEnd=chartDestroyEvents.length;i<iEnd;++i){const events=chartDestroyEvents[i];if(events[0]===this){events[1].forEach(unbind=>unbind());chartDestroyEvents.splice(i,1);return}}}function onChartGetMargins(){const rangeSelector=this.rangeSelector;if(rangeSelector?.options?.enabled){const rangeSelectorHeight=rangeSelector.getHeight();const verticalAlign=rangeSelector.options.verticalAlign;if(!rangeSelector.options.floating){if(verticalAlign==="bottom"){this.marginBottom+=rangeSelectorHeight}else if(verticalAlign!=="middle"){this.plotTop+=rangeSelectorHeight}}}}function RangeSelectorComposition_onChartUpdate(e){const chart=this,options=e.options,optionsRangeSelector=options.rangeSelector,extraBottomMarginWas=this.extraBottomMargin,extraTopMarginWas=this.extraTopMargin;let rangeSelector=chart.rangeSelector;if(optionsRangeSelector&&optionsRangeSelector.enabled&&!RangeSelectorComposition_defined(rangeSelector)&&this.options.rangeSelector){this.options.rangeSelector.enabled=true;this.rangeSelector=rangeSelector=new RangeSelectorConstructor(this)}this.extraBottomMargin=false;this.extraTopMargin=false;if(rangeSelector){const verticalAlign=optionsRangeSelector&&optionsRangeSelector.verticalAlign||rangeSelector.options&&rangeSelector.options.verticalAlign;if(!rangeSelector.options.floating){if(verticalAlign==="bottom"){this.extraBottomMargin=true}else if(verticalAlign!=="middle"){this.extraTopMargin=true}}if(this.extraBottomMargin!==extraBottomMarginWas||this.extraTopMargin!==extraTopMarginWas){this.isDirtyBox=true}}}const RangeSelectorComposition={compose:RangeSelectorComposition_compose};const RangeSelector_RangeSelectorComposition=RangeSelectorComposition;var highcharts_SVGElement_commonjs_highcharts_SVGElement_commonjs2_highcharts_SVGElement_root_Highcharts_SVGElement_=__webpack_require__(28);var highcharts_SVGElement_commonjs_highcharts_SVGElement_commonjs2_highcharts_SVGElement_root_Highcharts_SVGElement_default=__webpack_require__.n(highcharts_SVGElement_commonjs_highcharts_SVGElement_commonjs2_highcharts_SVGElement_root_Highcharts_SVGElement_);const{fireEvent:DataTableCore_fireEvent,isArray:DataTableCore_isArray,objectEach:DataTableCore_objectEach,uniqueKey}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();class DataTableCore{constructor(options={}){this.autoId=!options.id;this.columns={};this.id=options.id||uniqueKey();this.modified=this;this.rowCount=0;this.versionTag=uniqueKey();let rowCount=0;DataTableCore_objectEach(options.columns||{},(column,columnName)=>{this.columns[columnName]=column.slice();rowCount=Math.max(rowCount,column.length)});this.applyRowCount(rowCount)}applyRowCount(rowCount){this.rowCount=rowCount;DataTableCore_objectEach(this.columns,column=>{if(DataTableCore_isArray(column)){column.length=rowCount}})}getColumn(columnName,asReference){return this.columns[columnName]}getColumns(columnNames,asReference){return(columnNames||Object.keys(this.columns)).reduce((columns,columnName)=>{columns[columnName]=this.columns[columnName];return columns},{})}getRow(rowIndex,columnNames){return(columnNames||Object.keys(this.columns)).map(key=>this.columns[key]?.[rowIndex])}setColumn(columnName,column=[],rowIndex=0,eventDetail){this.setColumns({[columnName]:column},rowIndex,eventDetail)}setColumns(columns,rowIndex,eventDetail){let rowCount=this.rowCount;DataTableCore_objectEach(columns,(column,columnName)=>{this.columns[columnName]=column.slice();rowCount=column.length});this.applyRowCount(rowCount);if(!eventDetail?.silent){DataTableCore_fireEvent(this,"afterSetColumns");this.versionTag=uniqueKey()}}setRow(row,rowIndex=this.rowCount,insert,eventDetail){const{columns}=this,indexRowCount=insert?this.rowCount+1:rowIndex+1;DataTableCore_objectEach(row,(cellValue,columnName)=>{const column=columns[columnName]||eventDetail?.addColumns!==false&&new Array(indexRowCount);if(column){if(insert){column.splice(rowIndex,0,cellValue)}else{column[rowIndex]=cellValue}columns[columnName]=column}});if(indexRowCount>this.rowCount){this.applyRowCount(indexRowCount)}if(!eventDetail?.silent){DataTableCore_fireEvent(this,"afterSetRows");this.versionTag=uniqueKey()}}}const Data_DataTableCore=DataTableCore;"";const{addEvent:OrdinalAxis_addEvent,correctFloat:OrdinalAxis_correctFloat,css,defined:OrdinalAxis_defined,error:OrdinalAxis_error,isNumber:OrdinalAxis_isNumber,pick:OrdinalAxis_pick,timeUnits,isString}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();var OrdinalAxis;(function(OrdinalAxis){function compose(AxisClass,SeriesClass,ChartClass){const axisProto=AxisClass.prototype;if(!axisProto.ordinal2lin){axisProto.getTimeTicks=getTimeTicks;axisProto.index2val=index2val;axisProto.lin2val=lin2val;axisProto.val2lin=val2lin;axisProto.ordinal2lin=axisProto.val2lin;OrdinalAxis_addEvent(AxisClass,"afterInit",onAxisAfterInit);OrdinalAxis_addEvent(AxisClass,"foundExtremes",onAxisFoundExtremes);OrdinalAxis_addEvent(AxisClass,"afterSetScale",onAxisAfterSetScale);OrdinalAxis_addEvent(AxisClass,"initialAxisTranslation",onAxisInitialAxisTranslation);OrdinalAxis_addEvent(ChartClass,"pan",onChartPan);OrdinalAxis_addEvent(ChartClass,"touchpan",onChartPan);OrdinalAxis_addEvent(SeriesClass,"updatedData",onSeriesUpdatedData)}return AxisClass}OrdinalAxis.compose=compose;function getTimeTicks(normalizedInterval,min,max,startOfWeek,positions=[],closestDistance=0,findHigherRanks){const higherRanks={},tickPixelIntervalOption=this.options.tickPixelInterval,time=this.chart.time,segmentStarts=[];let end,segmentPositions,hasCrossedHigherRank,info,outsideMax,start=0,groupPositions=[],lastGroupPosition=-Number.MAX_VALUE;if(!this.options.ordinal&&!this.options.breaks||!positions||positions.length<3||typeof min==="undefined"){return time.getTimeTicks.apply(time,arguments)}const posLength=positions.length;for(end=0;end<posLength;end++){outsideMax=end&&positions[end-1]>max;if(positions[end]<min){start=end}if(end===posLength-1||positions[end+1]-positions[end]>closestDistance*5||outsideMax){if(positions[end]>lastGroupPosition){segmentPositions=time.getTimeTicks(normalizedInterval,positions[start],positions[end],startOfWeek);while(segmentPositions.length&&segmentPositions[0]<=lastGroupPosition){segmentPositions.shift()}if(segmentPositions.length){lastGroupPosition=segmentPositions[segmentPositions.length-1]}segmentStarts.push(groupPositions.length);groupPositions=groupPositions.concat(segmentPositions)}start=end+1}if(outsideMax){break}}if(segmentPositions){info=segmentPositions.info;if(findHigherRanks&&info.unitRange<=timeUnits.hour){end=groupPositions.length-1;for(start=1;start<end;start++){if(time.dateFormat("%d",groupPositions[start])!==time.dateFormat("%d",groupPositions[start-1])){higherRanks[groupPositions[start]]="day";hasCrossedHigherRank=true}}if(hasCrossedHigherRank){higherRanks[groupPositions[0]]="day"}info.higherRanks=higherRanks}info.segmentStarts=segmentStarts;groupPositions.info=info}else{OrdinalAxis_error(12,false,this.chart)}if(findHigherRanks&&OrdinalAxis_defined(tickPixelIntervalOption)){const length=groupPositions.length,translatedArr=[],distances=[];let itemToRemove,translated,lastTranslated,medianDistance,distance,i=length;while(i--){translated=this.translate(groupPositions[i]);if(lastTranslated){distances[i]=lastTranslated-translated}translatedArr[i]=lastTranslated=translated}distances.sort((a,b)=>a-b);medianDistance=distances[Math.floor(distances.length/2)];if(medianDistance<tickPixelIntervalOption*.6){medianDistance=null}i=groupPositions[length-1]>max?length-1:length;lastTranslated=void 0;while(i--){translated=translatedArr[i];distance=Math.abs(lastTranslated-translated);if(lastTranslated&&distance<tickPixelIntervalOption*.8&&(medianDistance===null||distance<medianDistance*.8)){if(higherRanks[groupPositions[i]]&&!higherRanks[groupPositions[i+1]]){itemToRemove=i+1;lastTranslated=translated}else{itemToRemove=i}groupPositions.splice(itemToRemove,1)}else{lastTranslated=translated}}}return groupPositions}function index2val(index){const axis=this,ordinal=axis.ordinal,ordinalPositions=ordinal.positions;if(!ordinalPositions){return index}let i=ordinalPositions.length-1,distance;if(index<0){index=ordinalPositions[0]}else if(index>i){index=ordinalPositions[i]}else{i=Math.floor(index);distance=index-i}if(typeof distance!=="undefined"&&typeof ordinalPositions[i]!=="undefined"){return ordinalPositions[i]+(distance?distance*(ordinalPositions[i+1]-ordinalPositions[i]):0)}return index}function lin2val(val){const axis=this,ordinal=axis.ordinal,localMin=axis.old?axis.old.min:axis.min,localA=axis.old?axis.old.transA:axis.transA;const positions=ordinal.getExtendedPositions();if(positions?.length){const pixelVal=OrdinalAxis_correctFloat((val-localMin)*localA+axis.minPixelPadding),index=OrdinalAxis_correctFloat(ordinal.getIndexOfPoint(pixelVal,positions)),mantissa=OrdinalAxis_correctFloat(index%1);if(index>=0&&index<=positions.length-1){const leftNeighbour=positions[Math.floor(index)],rightNeighbour=positions[Math.ceil(index)],distance=rightNeighbour-leftNeighbour;return positions[Math.floor(index)]+mantissa*distance}}return val}function getIndexInArray(ordinalPositions,val){const index=OrdinalAxis.Additions.findIndexOf(ordinalPositions,val,true);if(ordinalPositions[index]===val){return index}const percent=(val-ordinalPositions[index])/(ordinalPositions[index+1]-ordinalPositions[index]);return index+percent}function onAxisAfterInit(){const axis=this;if(!axis.ordinal){axis.ordinal=new OrdinalAxis.Additions(axis)}}function onAxisFoundExtremes(){const axis=this,{eventArgs,options}=axis;if(axis.isXAxis&&OrdinalAxis_defined(options.overscroll)&&options.overscroll!==0&&OrdinalAxis_isNumber(axis.max)&&OrdinalAxis_isNumber(axis.min)){if(axis.options.ordinal&&!axis.ordinal.originalOrdinalRange){axis.ordinal.getExtendedPositions(false)}if(axis.max===axis.dataMax&&(eventArgs?.trigger!=="pan"||axis.isInternal)&&eventArgs?.trigger!=="navigator"){const overscroll=axis.ordinal.convertOverscroll(options.overscroll);axis.max+=overscroll;if(!axis.isInternal&&OrdinalAxis_defined(axis.userMin)&&eventArgs?.trigger!=="mousewheel"){axis.min+=overscroll}}}}function onAxisAfterSetScale(){const axis=this;if(axis.horiz&&!axis.isDirty){axis.isDirty=axis.isOrdinal&&axis.chart.navigator&&!axis.chart.navigator.adaptToUpdatedData}}function onAxisInitialAxisTranslation(){const axis=this;if(axis.ordinal){axis.ordinal.beforeSetTickPositions();axis.tickInterval=axis.ordinal.postProcessTickInterval(axis.tickInterval)}}function onChartPan(e){const chart=this,xAxis=chart.xAxis[0],overscroll=xAxis.ordinal.convertOverscroll(xAxis.options.overscroll),chartX=e.originalEvent.chartX,panning=chart.options.chart.panning;let runBase=false;if(panning&&panning.type!=="y"&&xAxis.options.ordinal&&xAxis.series.length&&(!e.touches||e.touches.length<=1)){const mouseDownX=chart.mouseDownX,extremes=xAxis.getExtremes(),dataMin=extremes.dataMin,dataMax=extremes.dataMax,min=extremes.min,max=extremes.max,hoverPoints=chart.hoverPoints,closestPointRange=xAxis.closestPointRange||xAxis.ordinal&&xAxis.ordinal.overscrollPointsRange,pointPixelWidth=xAxis.translationSlope*(xAxis.ordinal.slope||closestPointRange),movedUnits=Math.round((mouseDownX-chartX)/pointPixelWidth),extendedOrdinalPositions=xAxis.ordinal.getExtendedPositions(),extendedAxis={ordinal:{positions:extendedOrdinalPositions,extendedOrdinalPositions:extendedOrdinalPositions}},index2val=xAxis.index2val,val2lin=xAxis.val2lin;let trimmedRange,ordinalPositions;if(min<=dataMin&&movedUnits<0||max+overscroll>=dataMax&&movedUnits>0){return}if(!extendedAxis.ordinal.positions){runBase=true}else if(Math.abs(movedUnits)>1){if(hoverPoints){hoverPoints.forEach(function(point){point.setState()})}ordinalPositions=extendedAxis.ordinal.positions;if(dataMax>ordinalPositions[ordinalPositions.length-1]){ordinalPositions.push(dataMax)}chart.setFixedRange(max-min);trimmedRange=xAxis.navigatorAxis.toFixedRange(void 0,void 0,index2val.apply(extendedAxis,[val2lin.apply(extendedAxis,[min,true])+movedUnits]),index2val.apply(extendedAxis,[val2lin.apply(extendedAxis,[max,true])+movedUnits]));if(trimmedRange.min>=Math.min(ordinalPositions[0],min)&&trimmedRange.max<=Math.max(ordinalPositions[ordinalPositions.length-1],max)+overscroll){xAxis.setExtremes(trimmedRange.min,trimmedRange.max,true,false,{trigger:"pan"})}chart.mouseDownX=chartX;css(chart.container,{cursor:"move"})}}else{runBase=true}if(runBase||panning&&/y/.test(panning.type)){if(overscroll){xAxis.max=xAxis.dataMax+overscroll}}else{e.preventDefault()}}function onSeriesUpdatedData(){const xAxis=this.xAxis;if(xAxis&&xAxis.options.ordinal){delete xAxis.ordinal.index;delete xAxis.ordinal.originalOrdinalRange}}function val2lin(val,toIndex){const axis=this,ordinal=axis.ordinal,ordinalPositions=ordinal.positions;let slope=ordinal.slope,extendedOrdinalPositions;if(!ordinalPositions){return val}const ordinalLength=ordinalPositions.length;let ordinalIndex;if(ordinalPositions[0]<=val&&ordinalPositions[ordinalLength-1]>=val){ordinalIndex=getIndexInArray(ordinalPositions,val)}else{extendedOrdinalPositions=ordinal.getExtendedPositions&&ordinal.getExtendedPositions();if(!(extendedOrdinalPositions&&extendedOrdinalPositions.length)){return val}const length=extendedOrdinalPositions.length;if(!slope){slope=(extendedOrdinalPositions[length-1]-extendedOrdinalPositions[0])/length}const originalPositionsReference=getIndexInArray(extendedOrdinalPositions,ordinalPositions[0]);if(val>=extendedOrdinalPositions[0]&&val<=extendedOrdinalPositions[length-1]){ordinalIndex=getIndexInArray(extendedOrdinalPositions,val)-originalPositionsReference}else{if(!toIndex){return val}if(val<extendedOrdinalPositions[0]){const diff=extendedOrdinalPositions[0]-val,approximateIndexOffset=diff/slope;ordinalIndex=-originalPositionsReference-approximateIndexOffset}else{const diff=val-extendedOrdinalPositions[length-1],approximateIndexOffset=diff/slope;ordinalIndex=approximateIndexOffset+length-originalPositionsReference}}}return toIndex?ordinalIndex:slope*(ordinalIndex||0)+ordinal.offset}class Additions{constructor(axis){this.index={};this.axis=axis}beforeSetTickPositions(){const axis=this.axis,ordinal=axis.ordinal,extremes=axis.getExtremes(),min=extremes.min,max=extremes.max,hasBreaks=axis.brokenAxis?.hasBreaks,isOrdinal=axis.options.ordinal;let len,uniqueOrdinalPositions,dist,minIndex,maxIndex,slope,i,ordinalPositions=[],overscrollPointsRange=Number.MAX_VALUE,useOrdinal=false,adjustOrdinalExtremesPoints=false,isBoosted=false;if(isOrdinal||hasBreaks){let distanceBetweenPoint=0;axis.series.forEach(function(series,i){const xData=series.getColumn("x",true);uniqueOrdinalPositions=[];if(i>0&&series.options.id!=="highcharts-navigator-series"&&xData.length>1){adjustOrdinalExtremesPoints=distanceBetweenPoint!==xData[1]-xData[0]}distanceBetweenPoint=xData[1]-xData[0];if(series.boosted){isBoosted=series.boosted}if(series.reserveSpace()&&(series.takeOrdinalPosition!==false||hasBreaks)){ordinalPositions=ordinalPositions.concat(xData);len=ordinalPositions.length;ordinalPositions.sort(function(a,b){return a-b});overscrollPointsRange=Math.min(overscrollPointsRange,OrdinalAxis_pick(series.closestPointRange,overscrollPointsRange));if(len){i=0;while(i<len-1){if(ordinalPositions[i]!==ordinalPositions[i+1]){uniqueOrdinalPositions.push(ordinalPositions[i+1])}i++}if(uniqueOrdinalPositions[0]!==ordinalPositions[0]){uniqueOrdinalPositions.unshift(ordinalPositions[0])}ordinalPositions=uniqueOrdinalPositions}}});if(!axis.ordinal.originalOrdinalRange){axis.ordinal.originalOrdinalRange=(ordinalPositions.length-1)*overscrollPointsRange}if(adjustOrdinalExtremesPoints&&isBoosted){ordinalPositions.pop();ordinalPositions.shift()}len=ordinalPositions.length;if(len>2){dist=ordinalPositions[1]-ordinalPositions[0];i=len-1;while(i--&&!useOrdinal){if(ordinalPositions[i+1]-ordinalPositions[i]!==dist){useOrdinal=true}}if(!axis.options.keepOrdinalPadding&&(ordinalPositions[0]-min>dist||max-ordinalPositions[ordinalPositions.length-1]>dist)){useOrdinal=true}}else if(axis.options.overscroll){if(len===2){overscrollPointsRange=ordinalPositions[1]-ordinalPositions[0]}else if(len===1){overscrollPointsRange=axis.ordinal.convertOverscroll(axis.options.overscroll);ordinalPositions=[ordinalPositions[0],ordinalPositions[0]+overscrollPointsRange]}else{overscrollPointsRange=ordinal.overscrollPointsRange}}if(useOrdinal||axis.forceOrdinal){if(axis.options.overscroll){ordinal.overscrollPointsRange=overscrollPointsRange;ordinalPositions=ordinalPositions.concat(ordinal.getOverscrollPositions())}ordinal.positions=ordinalPositions;minIndex=axis.ordinal2lin(Math.max(min,ordinalPositions[0]),true);maxIndex=Math.max(axis.ordinal2lin(Math.min(max,ordinalPositions[ordinalPositions.length-1]),true),1);ordinal.slope=slope=(max-min)/(maxIndex-minIndex);ordinal.offset=min-minIndex*slope}else{ordinal.overscrollPointsRange=OrdinalAxis_pick(axis.closestPointRange,ordinal.overscrollPointsRange);ordinal.positions=axis.ordinal.slope=ordinal.offset=void 0}}axis.isOrdinal=isOrdinal&&useOrdinal;ordinal.groupIntervalFactor=null}static findIndexOf(sortedArray,key,indirectSearch){let start=0,end=sortedArray.length-1,middle;while(start<end){middle=Math.ceil((start+end)/2);if(sortedArray[middle]<=key){start=middle}else{end=middle-1}}if(sortedArray[start]===key){return start}return!indirectSearch?-1:start}getExtendedPositions(withOverscroll=true){const ordinal=this,axis=ordinal.axis,axisProto=axis.constructor.prototype,chart=axis.chart,key=axis.series.reduce((k,series)=>{const grouping=series.currentDataGrouping;return k+(grouping?grouping.count+grouping.unitName:"raw")},""),overscroll=withOverscroll?axis.ordinal.convertOverscroll(axis.options.overscroll):0,extremes=axis.getExtremes();let fakeAxis,fakeSeries=void 0,ordinalIndex=ordinal.index;if(!ordinalIndex){ordinalIndex=ordinal.index={}}if(!ordinalIndex[key]){fakeAxis={series:[],chart:chart,forceOrdinal:false,getExtremes:function(){return{min:extremes.dataMin,max:extremes.dataMax+overscroll}},applyGrouping:axisProto.applyGrouping,getGroupPixelWidth:axisProto.getGroupPixelWidth,getTimeTicks:axisProto.getTimeTicks,options:{ordinal:true},ordinal:{getGroupIntervalFactor:this.getGroupIntervalFactor},ordinal2lin:axisProto.ordinal2lin,getIndexOfPoint:axisProto.getIndexOfPoint,val2lin:axisProto.val2lin};fakeAxis.ordinal.axis=fakeAxis;axis.series.forEach(series=>{fakeSeries={xAxis:fakeAxis,chart:chart,groupPixelWidth:series.groupPixelWidth,destroyGroupedData:highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().noop,getColumn:series.getColumn,applyGrouping:series.applyGrouping,getProcessedData:series.getProcessedData,reserveSpace:series.reserveSpace,visible:series.visible};const xData=series.getColumn("x").concat(withOverscroll?ordinal.getOverscrollPositions():[]);fakeSeries.dataTable=new Data_DataTableCore({columns:{x:xData}});fakeSeries.options={...series.options,dataGrouping:series.currentDataGrouping?{firstAnchor:series.options.dataGrouping?.firstAnchor,anchor:series.options.dataGrouping?.anchor,lastAnchor:series.options.dataGrouping?.firstAnchor,enabled:true,forced:true,approximation:"open",units:[[series.currentDataGrouping.unitName,[series.currentDataGrouping.count]]]}:{enabled:false}};fakeAxis.series.push(fakeSeries);series.processData.apply(fakeSeries)});fakeAxis.applyGrouping({hasExtremesChanged:true});if(fakeSeries?.closestPointRange!==fakeSeries?.basePointRange&&fakeSeries.currentDataGrouping){fakeAxis.forceOrdinal=true}axis.ordinal.beforeSetTickPositions.apply({axis:fakeAxis});if(!axis.ordinal.originalOrdinalRange&&fakeAxis.ordinal.originalOrdinalRange){axis.ordinal.originalOrdinalRange=fakeAxis.ordinal.originalOrdinalRange}if(fakeAxis.ordinal.positions){ordinalIndex[key]=fakeAxis.ordinal.positions}}return ordinalIndex[key]}getGroupIntervalFactor(xMin,xMax,series){const ordinal=this,processedXData=series.getColumn("x",true),len=processedXData.length,distances=[];let median,i,groupIntervalFactor=ordinal.groupIntervalFactor;if(!groupIntervalFactor){for(i=0;i<len-1;i++){distances[i]=processedXData[i+1]-processedXData[i]}distances.sort(function(a,b){return a-b});median=distances[Math.floor(len/2)];xMin=Math.max(xMin,processedXData[0]);xMax=Math.min(xMax,processedXData[len-1]);ordinal.groupIntervalFactor=groupIntervalFactor=len*median/(xMax-xMin)}return groupIntervalFactor}getIndexOfPoint(pixelVal,ordinalArray){const ordinal=this,axis=ordinal.axis,min=axis.min,minX=axis.minPixelPadding,indexOfMin=getIndexInArray(ordinalArray,min);const ordinalPointPixelInterval=axis.translationSlope*(ordinal.slope||axis.closestPointRange||ordinal.overscrollPointsRange);const shiftIndex=OrdinalAxis_correctFloat((pixelVal-minX)/ordinalPointPixelInterval);return indexOfMin+shiftIndex}getOverscrollPositions(){const ordinal=this,axis=ordinal.axis,extraRange=ordinal.convertOverscroll(axis.options.overscroll),distance=ordinal.overscrollPointsRange,positions=[];let max=axis.dataMax;if(OrdinalAxis_defined(distance)){while(max<axis.dataMax+extraRange){max+=distance;positions.push(max)}}return positions}postProcessTickInterval(tickInterval){const ordinal=this,axis=ordinal.axis,ordinalSlope=ordinal.slope,closestPointRange=axis.closestPointRange;let ret;if(ordinalSlope&&closestPointRange){if(!axis.options.breaks){ret=tickInterval/(ordinalSlope/closestPointRange)}else{ret=closestPointRange||tickInterval}}else{ret=tickInterval}return ret}convertOverscroll(overscroll=0){const ordinal=this,axis=ordinal.axis,calculateOverscroll=function(overscrollPercentage){return OrdinalAxis_pick(ordinal.originalOrdinalRange,OrdinalAxis_defined(axis.dataMax)&&OrdinalAxis_defined(axis.dataMin)?axis.dataMax-axis.dataMin:0)*overscrollPercentage};if(isString(overscroll)){const overscrollValue=parseInt(overscroll,10);if(/%$/.test(overscroll)){return calculateOverscroll(overscrollValue/100)}if(/px/.test(overscroll)){const limitedOverscrollValue=Math.min(overscrollValue,axis.len*.9),pixelToPercent=limitedOverscrollValue/axis.len;return calculateOverscroll(pixelToPercent/(1-pixelToPercent))}return 0}return overscroll}}OrdinalAxis.Additions=Additions})(OrdinalAxis||(OrdinalAxis={}));const Axis_OrdinalAxis=OrdinalAxis;const{defaultOptions:RangeSelector_defaultOptions}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{addEvent:RangeSelector_addEvent,createElement,css:RangeSelector_css,defined:RangeSelector_defined,destroyObjectProperties:RangeSelector_destroyObjectProperties,diffObjects,discardElement,extend:RangeSelector_extend,fireEvent:RangeSelector_fireEvent,isNumber:RangeSelector_isNumber,isString:RangeSelector_isString,merge:RangeSelector_merge,objectEach:RangeSelector_objectEach,pick:RangeSelector_pick,splat:RangeSelector_splat}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function preferredInputType(format){const ms=RangeSelector_isString(format)?format.indexOf("%L")!==-1:format.fractionalSecondDigits;if(ms){return"text"}const date=RangeSelector_isString(format)?["a","A","d","e","w","b","B","m","o","y","Y"].some(char=>format.indexOf("%"+char)!==-1):format.dateStyle||format.day||format.month||format.year;const time=RangeSelector_isString(format)?["H","k","I","l","M","S"].some(char=>format.indexOf("%"+char)!==-1):format.timeStyle||format.hour||format.minute||format.second;if(date&&time){return"datetime-local"}if(date){return"date"}if(time){return"time"}return"text"}class RangeSelector{static compose(AxisClass,ChartClass){RangeSelector_RangeSelectorComposition.compose(AxisClass,ChartClass,RangeSelector)}constructor(chart){this.isDirty=false;this.buttonOptions=RangeSelector.prototype.defaultButtons;this.initialButtonGroupWidth=0;this.init(chart)}clickButton(i,redraw){const rangeSelector=this,chart=rangeSelector.chart,rangeOptions=rangeSelector.buttonOptions[i],baseAxis=chart.xAxis[0],unionExtremes=chart.scroller&&chart.scroller.getUnionExtremes()||baseAxis||{},type=rangeOptions.type,dataGrouping=rangeOptions.dataGrouping;let dataMin=unionExtremes.dataMin,dataMax=unionExtremes.dataMax,newMin,newMax=RangeSelector_isNumber(baseAxis?.max)?Math.round(Math.min(baseAxis.max,dataMax??baseAxis.max)):void 0,baseXAxisOptions,range=rangeOptions._range,rangeMin,ctx,ytdExtremes,addOffsetMin=true;if(dataMin===null||dataMax===null){return}rangeSelector.setSelected(i);if(dataGrouping){this.forcedDataGrouping=true;highcharts_Axis_commonjs_highcharts_Axis_commonjs2_highcharts_Axis_root_Highcharts_Axis_default().prototype.setDataGrouping.call(baseAxis||{chart:this.chart},dataGrouping,false);this.frozenStates=rangeOptions.preserveDataGrouping}if(type==="month"||type==="year"){if(!baseAxis){range=rangeOptions}else{ctx={range:rangeOptions,max:newMax,chart:chart,dataMin:dataMin,dataMax:dataMax};newMin=baseAxis.minFromRange.call(ctx);if(RangeSelector_isNumber(ctx.newMax)){newMax=ctx.newMax}addOffsetMin=false}}else if(range){if(RangeSelector_isNumber(newMax)){newMin=Math.max(newMax-range,dataMin);newMax=Math.min(newMin+range,dataMax);addOffsetMin=false}}else if(type==="ytd"){if(baseAxis){if(baseAxis.hasData()&&(!RangeSelector_isNumber(dataMax)||!RangeSelector_isNumber(dataMin))){dataMin=Number.MAX_VALUE;dataMax=-Number.MAX_VALUE;chart.series.forEach(series=>{const xData=series.getColumn("x");if(xData.length){dataMin=Math.min(xData[0],dataMin);dataMax=Math.max(xData[xData.length-1],dataMax)}});redraw=false}if(RangeSelector_isNumber(dataMax)&&RangeSelector_isNumber(dataMin)){ytdExtremes=rangeSelector.getYTDExtremes(dataMax,dataMin);newMin=rangeMin=ytdExtremes.min;newMax=ytdExtremes.max}}else{rangeSelector.deferredYTDClick=i;return}}else if(type==="all"&&baseAxis){if(chart.navigator&&chart.navigator.baseSeries[0]){chart.navigator.baseSeries[0].xAxis.options.range=void 0}newMin=dataMin;newMax=dataMax}if(addOffsetMin&&rangeOptions._offsetMin&&RangeSelector_defined(newMin)){newMin+=rangeOptions._offsetMin}if(rangeOptions._offsetMax&&RangeSelector_defined(newMax)){newMax+=rangeOptions._offsetMax}if(this.dropdown){this.dropdown.selectedIndex=i+1}if(!baseAxis){baseXAxisOptions=RangeSelector_splat(chart.options.xAxis||{})[0];const axisRangeUpdateEvent=RangeSelector_addEvent(chart,"afterCreateAxes",function(){const xAxis=chart.xAxis[0];xAxis.range=xAxis.options.range=range;xAxis.min=xAxis.options.min=rangeMin});RangeSelector_addEvent(chart,"load",function resetMinAndRange(){const xAxis=chart.xAxis[0];chart.setFixedRange(rangeOptions._range);xAxis.options.range=baseXAxisOptions.range;xAxis.options.min=baseXAxisOptions.min;axisRangeUpdateEvent()})}else if(RangeSelector_isNumber(newMin)&&RangeSelector_isNumber(newMax)){baseAxis.setExtremes(newMin,newMax,RangeSelector_pick(redraw,true),void 0,{trigger:"rangeSelectorButton",rangeSelectorButton:rangeOptions});chart.setFixedRange(rangeOptions._range)}RangeSelector_fireEvent(this,"afterBtnClick")}setSelected(selected){this.selected=this.options.selected=selected}init(chart){const rangeSelector=this,options=chart.options.rangeSelector,buttonOptions=options.buttons,selectedOption=options.selected,blurInputs=function(){const minInput=rangeSelector.minInput,maxInput=rangeSelector.maxInput;if(minInput&&!!minInput.blur){RangeSelector_fireEvent(minInput,"blur")}if(maxInput&&!!maxInput.blur){RangeSelector_fireEvent(maxInput,"blur")}};rangeSelector.chart=chart;rangeSelector.options=options;rangeSelector.buttons=[];rangeSelector.buttonOptions=buttonOptions;this.eventsToUnbind=[];this.eventsToUnbind.push(RangeSelector_addEvent(chart.container,"mousedown",blurInputs));this.eventsToUnbind.push(RangeSelector_addEvent(chart,"resize",blurInputs));buttonOptions.forEach(rangeSelector.computeButtonRange);if(typeof selectedOption!=="undefined"&&buttonOptions[selectedOption]){this.clickButton(selectedOption,false)}this.eventsToUnbind.push(RangeSelector_addEvent(chart,"load",function(){if(chart.xAxis&&chart.xAxis[0]){RangeSelector_addEvent(chart.xAxis[0],"setExtremes",function(e){if(RangeSelector_isNumber(this.max)&&RangeSelector_isNumber(this.min)&&this.max-this.min!==chart.fixedRange&&e.trigger!=="rangeSelectorButton"&&e.trigger!=="updatedData"&&rangeSelector.forcedDataGrouping&&!rangeSelector.frozenStates){this.setDataGrouping(false,false)}})}}));this.createElements()}updateButtonStates(){const rangeSelector=this,chart=this.chart,dropdown=this.dropdown,dropdownLabel=this.dropdownLabel,baseAxis=chart.xAxis[0],actualRange=Math.round(baseAxis.max-baseAxis.min),hasNoData=!baseAxis.hasVisibleSeries,day=24*36e5,unionExtremes=chart.scroller&&chart.scroller.getUnionExtremes()||baseAxis,dataMin=unionExtremes.dataMin,dataMax=unionExtremes.dataMax,ytdExtremes=rangeSelector.getYTDExtremes(dataMax,dataMin),ytdMin=ytdExtremes.min,ytdMax=ytdExtremes.max,selected=rangeSelector.selected,allButtonsEnabled=rangeSelector.options.allButtonsEnabled,buttonStates=new Array(rangeSelector.buttonOptions.length).fill(0),selectedExists=RangeSelector_isNumber(selected),buttons=rangeSelector.buttons;let isSelectedTooGreat=false,selectedIndex=null;rangeSelector.buttonOptions.forEach((rangeOptions,i)=>{const range=rangeOptions._range,type=rangeOptions.type,count=rangeOptions.count||1,offsetRange=rangeOptions._offsetMax-rangeOptions._offsetMin,isSelected=i===selected,isTooGreatRange=range>dataMax-dataMin,isTooSmallRange=range<baseAxis.minRange;let isYTDButNotSelected=false,isSameRange=range===actualRange;if(isSelected&&isTooGreatRange){isSelectedTooGreat=true}if(baseAxis.isOrdinal&&baseAxis.ordinal?.positions&&range&&actualRange<range){const positions=baseAxis.ordinal.positions,prevOrdinalPosition=Axis_OrdinalAxis.Additions.findIndexOf(positions,baseAxis.min,true),nextOrdinalPosition=Math.min(Axis_OrdinalAxis.Additions.findIndexOf(positions,baseAxis.max,true)+1,positions.length-1);if(positions[nextOrdinalPosition]-positions[prevOrdinalPosition]>range){isSameRange=true}}else if((type==="month"||type==="year")&&actualRange+36e5>={month:28,year:365}[type]*day*count-offsetRange&&actualRange-36e5<={month:31,year:366}[type]*day*count+offsetRange){isSameRange=true}else if(type==="ytd"){isSameRange=ytdMax-ytdMin+offsetRange===actualRange;isYTDButNotSelected=!isSelected}else if(type==="all"){isSameRange=baseAxis.max-baseAxis.min>=dataMax-dataMin}const disable=!allButtonsEnabled&&!(isSelectedTooGreat&&type==="all")&&(isTooGreatRange||isTooSmallRange||hasNoData);const select=isSelectedTooGreat&&type==="all"||(isYTDButNotSelected?false:isSameRange)||isSelected&&rangeSelector.frozenStates;if(disable){buttonStates[i]=3}else if(select){if(!selectedExists||i===selected){selectedIndex=i}}});if(selectedIndex!==null){buttonStates[selectedIndex]=2;rangeSelector.setSelected(selectedIndex)}else{rangeSelector.setSelected();if(dropdownLabel){dropdownLabel.setState(0);dropdownLabel.attr({text:(RangeSelector_defaultOptions.lang.rangeSelectorZoom||"")+" "})}}for(let i=0;i<buttonStates.length;i++){const state=buttonStates[i];const button=buttons[i];if(button.state!==state){button.setState(state);if(dropdown){dropdown.options[i+1].disabled=state===3;if(state===2){if(dropdownLabel){dropdownLabel.setState(2);dropdownLabel.attr({text:rangeSelector.buttonOptions[i].text+" "})}dropdown.selectedIndex=i+1}const bbox=dropdownLabel.getBBox();RangeSelector_css(dropdown,{width:`${bbox.width}px`,height:`${bbox.height}px`})}}}}computeButtonRange(rangeOptions){const type=rangeOptions.type,count=rangeOptions.count||1,fixedTimes={millisecond:1,second:1e3,minute:60*1e3,hour:3600*1e3,day:24*3600*1e3,week:7*24*3600*1e3};if(fixedTimes[type]){rangeOptions._range=fixedTimes[type]*count}else if(type==="month"||type==="year"){rangeOptions._range={month:30,year:365}[type]*24*36e5*count}rangeOptions._offsetMin=RangeSelector_pick(rangeOptions.offsetMin,0);rangeOptions._offsetMax=RangeSelector_pick(rangeOptions.offsetMax,0);rangeOptions._range+=rangeOptions._offsetMax-rangeOptions._offsetMin}getInputValue(name){const input=name==="min"?this.minInput:this.maxInput;const options=this.chart.options.rangeSelector;const time=this.chart.time;if(input){return(input.type==="text"&&options.inputDateParser||this.defaultInputDateParser)(input.value,time.timezone==="UTC",time)}return 0}setInputValue(name,inputTime){const options=this.options,time=this.chart.time,input=name==="min"?this.minInput:this.maxInput,dateBox=name==="min"?this.minDateBox:this.maxDateBox;if(input){input.setAttribute("type",preferredInputType(options.inputDateFormat||"%e %b %Y"));const hcTimeAttr=input.getAttribute("data-hc-time");let updatedTime=RangeSelector_defined(hcTimeAttr)?Number(hcTimeAttr):void 0;if(RangeSelector_defined(inputTime)){const previousTime=updatedTime;if(RangeSelector_defined(previousTime)){input.setAttribute("data-hc-time-previous",previousTime)}input.setAttribute("data-hc-time",inputTime);updatedTime=inputTime}input.value=time.dateFormat(this.inputTypeFormats[input.type]||options.inputEditDateFormat,updatedTime);if(dateBox){dateBox.attr({text:time.dateFormat(options.inputDateFormat,updatedTime)})}}}setInputExtremes(name,min,max){const input=name==="min"?this.minInput:this.maxInput;if(input){const format=this.inputTypeFormats[input.type];const time=this.chart.time;if(format){const newMin=time.dateFormat(format,min);if(input.min!==newMin){input.min=newMin}const newMax=time.dateFormat(format,max);if(input.max!==newMax){input.max=newMax}}}}showInput(name){const dateBox=name==="min"?this.minDateBox:this.maxDateBox,input=name==="min"?this.minInput:this.maxInput;if(input&&dateBox&&this.inputGroup){const isTextInput=input.type==="text",{translateX=0,translateY=0}=this.inputGroup,{x=0,width=0,height=0}=dateBox,{inputBoxWidth}=this.options;RangeSelector_css(input,{width:isTextInput?width+(inputBoxWidth?-2:20)+"px":"auto",height:height-2+"px",border:"2px solid silver"});if(isTextInput&&inputBoxWidth){RangeSelector_css(input,{left:translateX+x+"px",top:translateY+"px"})}else{RangeSelector_css(input,{left:Math.min(Math.round(x+translateX-(input.offsetWidth-width)/2),this.chart.chartWidth-input.offsetWidth)+"px",top:translateY-(input.offsetHeight-height)/2+"px"})}}}hideInput(name){const input=name==="min"?this.minInput:this.maxInput;if(input){RangeSelector_css(input,{top:"-9999em",border:0,width:"1px",height:"1px"})}}defaultInputDateParser(inputDate,useUTC,time){return time?.parse(inputDate)||0}drawInput(name){const{chart,div,inputGroup}=this;const rangeSelector=this,chartStyle=chart.renderer.style||{},renderer=chart.renderer,options=chart.options.rangeSelector,lang=RangeSelector_defaultOptions.lang,isMin=name==="min";function updateExtremes(name){const{maxInput,minInput}=rangeSelector,chartAxis=chart.xAxis[0],unionExtremes=chart.scroller?.getUnionExtremes()||chartAxis,dataMin=unionExtremes.dataMin,dataMax=unionExtremes.dataMax,currentExtreme=chart.xAxis[0].getExtremes()[name];let value=rangeSelector.getInputValue(name);if(RangeSelector_isNumber(value)&&value!==currentExtreme){if(isMin&&maxInput&&RangeSelector_isNumber(dataMin)){if(value>Number(maxInput.getAttribute("data-hc-time"))){value=void 0}else if(value<dataMin){value=dataMin}}else if(minInput&&RangeSelector_isNumber(dataMax)){if(value<Number(minInput.getAttribute("data-hc-time"))){value=void 0}else if(value>dataMax){value=dataMax}}if(typeof value!=="undefined"){chartAxis.setExtremes(isMin?value:chartAxis.min,isMin?chartAxis.max:value,void 0,void 0,{trigger:"rangeSelectorInput"})}}}const text=lang[isMin?"rangeSelectorFrom":"rangeSelectorTo"]||"";const label=renderer.label(text,0).addClass("highcharts-range-label").attr({padding:text?2:0,height:text?options.inputBoxHeight:0}).add(inputGroup);const dateBox=renderer.label("",0).addClass("highcharts-range-input").attr({padding:2,width:options.inputBoxWidth,height:options.inputBoxHeight,"text-align":"center"}).on("click",function(){rangeSelector.showInput(name);rangeSelector[name+"Input"].focus()});if(!chart.styledMode){dateBox.attr({stroke:options.inputBoxBorderColor,"stroke-width":1})}dateBox.add(inputGroup);const input=createElement("input",{name:name,className:"highcharts-range-selector"},void 0,div);input.setAttribute("type",preferredInputType(options.inputDateFormat||"%e %b %Y"));if(!chart.styledMode){label.css(RangeSelector_merge(chartStyle,options.labelStyle));dateBox.css(RangeSelector_merge({color:"#333333"},chartStyle,options.inputStyle));RangeSelector_css(input,RangeSelector_extend({position:"absolute",border:0,boxShadow:"0 0 15px rgba(0,0,0,0.3)",width:"1px",height:"1px",padding:0,textAlign:"center",fontSize:chartStyle.fontSize,fontFamily:chartStyle.fontFamily,top:"-9999em"},options.inputStyle))}input.onfocus=()=>{rangeSelector.showInput(name)};input.onblur=()=>{if(input===highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().doc.activeElement){updateExtremes(name)}rangeSelector.hideInput(name);rangeSelector.setInputValue(name);input.blur()};let keyDown=false;input.onchange=()=>{if(!keyDown){updateExtremes(name);rangeSelector.hideInput(name);input.blur()}};input.onkeypress=event=>{if(event.keyCode===13){updateExtremes(name)}};input.onkeydown=event=>{keyDown=true;if(event.key==="ArrowUp"||event.key==="ArrowDown"||event.key==="Tab"){updateExtremes(name)}};input.onkeyup=()=>{keyDown=false};return{dateBox:dateBox,input:input,label:label}}getPosition(){const chart=this.chart,options=chart.options.rangeSelector,top=options.verticalAlign==="top"?chart.plotTop-chart.axisOffset[0]:0;return{buttonTop:top+options.buttonPosition.y,inputTop:top+options.inputPosition.y-10}}getYTDExtremes(dataMax,dataMin){const time=this.chart.time,year=time.toParts(dataMax)[0],startOfYear=time.makeTime(year,0);return{max:dataMax,min:Math.max(dataMin,startOfYear)}}createElements(){const chart=this.chart,renderer=chart.renderer,container=chart.container,chartOptions=chart.options,options=chartOptions.rangeSelector,inputEnabled=options.inputEnabled,inputsZIndex=RangeSelector_pick(chartOptions.chart.style?.zIndex,0)+1;if(options.enabled===false){return}this.group=renderer.g("range-selector-group").attr({zIndex:7}).add();this.div=createElement("div",void 0,{position:"relative",height:0,zIndex:inputsZIndex});if(this.buttonOptions.length){this.renderButtons()}if(container.parentNode){container.parentNode.insertBefore(this.div,container)}if(inputEnabled){this.createInputs()}}createInputs(){this.inputGroup=this.chart.renderer.g("input-group").add(this.group);const minElems=this.drawInput("min");this.minDateBox=minElems.dateBox;this.minLabel=minElems.label;this.minInput=minElems.input;const maxElems=this.drawInput("max");this.maxDateBox=maxElems.dateBox;this.maxLabel=maxElems.label;this.maxInput=maxElems.input}render(min,max){if(this.options.enabled===false){return}const chart=this.chart,chartOptions=chart.options,options=chartOptions.rangeSelector,inputEnabled=options.inputEnabled;if(inputEnabled){if(!this.inputGroup){this.createInputs()}this.setInputValue("min",min);this.setInputValue("max",max);if(!this.chart.styledMode){this.maxLabel?.css(options.labelStyle);this.minLabel?.css(options.labelStyle)}const unionExtremes=chart.scroller&&chart.scroller.getUnionExtremes()||chart.xAxis[0]||{};if(RangeSelector_defined(unionExtremes.dataMin)&&RangeSelector_defined(unionExtremes.dataMax)){const minRange=chart.xAxis[0].minRange||0;this.setInputExtremes("min",unionExtremes.dataMin,Math.min(unionExtremes.dataMax,this.getInputValue("max"))-minRange);this.setInputExtremes("max",Math.max(unionExtremes.dataMin,this.getInputValue("min"))+minRange,unionExtremes.dataMax)}if(this.inputGroup){let x=0;[this.minLabel,this.minDateBox,this.maxLabel,this.maxDateBox].forEach(label=>{if(label){const{width}=label.getBBox();if(width){label.attr({x:x});x+=width+options.inputSpacing}}})}}else{if(this.inputGroup){this.inputGroup.destroy();delete this.inputGroup}}if(!this.chart.styledMode){if(this.zoomText){this.zoomText.css(options.labelStyle)}}this.alignElements();this.updateButtonStates()}renderButtons(){var _a;const{chart,options}=this;const lang=RangeSelector_defaultOptions.lang;const renderer=chart.renderer;const buttonTheme=RangeSelector_merge(options.buttonTheme);const states=buttonTheme&&buttonTheme.states;delete buttonTheme.width;delete buttonTheme.states;this.buttonGroup=renderer.g("range-selector-buttons").add(this.group);const dropdown=this.dropdown=createElement("select",void 0,{position:"absolute",padding:0,border:0,cursor:"pointer",opacity:1e-4},this.div);const userButtonTheme=chart.userOptions.rangeSelector?.buttonTheme;this.dropdownLabel=renderer.button("",0,0,()=>{},RangeSelector_merge(buttonTheme,{"stroke-width":RangeSelector_pick(buttonTheme["stroke-width"],0),width:"auto",paddingLeft:RangeSelector_pick(options.buttonTheme.paddingLeft,userButtonTheme?.padding,8),paddingRight:RangeSelector_pick(options.buttonTheme.paddingRight,userButtonTheme?.padding,8)}),states&&states.hover,states&&states.select,states&&states.disabled).hide().add(this.group);RangeSelector_addEvent(dropdown,"touchstart",()=>{dropdown.style.fontSize="16px"});const mouseOver=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().isMS?"mouseover":"mouseenter",mouseOut=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().isMS?"mouseout":"mouseleave";RangeSelector_addEvent(dropdown,mouseOver,()=>{RangeSelector_fireEvent(this.dropdownLabel.element,mouseOver)});RangeSelector_addEvent(dropdown,mouseOut,()=>{RangeSelector_fireEvent(this.dropdownLabel.element,mouseOut)});RangeSelector_addEvent(dropdown,"change",()=>{const button=this.buttons[dropdown.selectedIndex-1];RangeSelector_fireEvent(button.element,"click")});this.zoomText=renderer.label(lang.rangeSelectorZoom||"",0).attr({padding:options.buttonTheme.padding,height:options.buttonTheme.height,paddingLeft:0,paddingRight:0}).add(this.buttonGroup);if(!this.chart.styledMode){this.zoomText.css(options.labelStyle);(_a=options.buttonTheme)["stroke-width"]??(_a["stroke-width"]=0)}createElement("option",{textContent:this.zoomText.textStr,disabled:true},void 0,dropdown);this.createButtons()}createButtons(){const{options}=this;const buttonTheme=RangeSelector_merge(options.buttonTheme);const states=buttonTheme&&buttonTheme.states;const width=buttonTheme.width||28;delete buttonTheme.width;delete buttonTheme.states;this.buttonOptions.forEach((rangeOptions,i)=>{this.createButton(rangeOptions,i,width,states)})}createButton(rangeOptions,i,width,states){const{dropdown,buttons,chart,options}=this;const renderer=chart.renderer;const buttonTheme=RangeSelector_merge(options.buttonTheme);dropdown?.add(createElement("option",{textContent:rangeOptions.title||rangeOptions.text}),i+2);buttons[i]=renderer.button(rangeOptions.text,0,0,e=>{const buttonEvents=rangeOptions.events&&rangeOptions.events.click;let callDefaultEvent;if(buttonEvents){callDefaultEvent=buttonEvents.call(rangeOptions,e)}if(callDefaultEvent!==false){this.clickButton(i)}this.isActive=true},buttonTheme,states&&states.hover,states&&states.select,states&&states.disabled).attr({"text-align":"center",width:width}).add(this.buttonGroup);if(rangeOptions.title){buttons[i].attr("title",rangeOptions.title)}}alignElements(){const{buttonGroup,buttons,chart,group,inputGroup,options,zoomText}=this;const chartOptions=chart.options;const navButtonOptions=chartOptions.exporting&&chartOptions.exporting.enabled!==false&&chartOptions.navigation&&chartOptions.navigation.buttonOptions;const{buttonPosition,inputPosition,verticalAlign}=options;const getXOffsetForExportButton=(group,position)=>{if(navButtonOptions&&this.titleCollision(chart)&&verticalAlign==="top"&&position.align==="right"&&position.y-group.getBBox().height-12<(navButtonOptions.y||0)+(navButtonOptions.height||0)+chart.spacing[0]){return-40}return 0};let plotLeft=chart.plotLeft;if(group&&buttonPosition&&inputPosition){let translateX=buttonPosition.x-chart.spacing[3];if(buttonGroup){this.positionButtons();if(!this.initialButtonGroupWidth){let width=0;if(zoomText){width+=zoomText.getBBox().width+5}buttons.forEach((button,i)=>{width+=button.width||0;if(i!==buttons.length-1){width+=options.buttonSpacing}});this.initialButtonGroupWidth=width}plotLeft-=chart.spacing[3];const xOffsetForExportButton=getXOffsetForExportButton(buttonGroup,buttonPosition);this.alignButtonGroup(xOffsetForExportButton);if(this.buttonGroup?.translateY){this.dropdownLabel.attr({y:this.buttonGroup.translateY})}group.placed=buttonGroup.placed=chart.hasLoaded}let xOffsetForExportButton=0;if(options.inputEnabled&&inputGroup){xOffsetForExportButton=getXOffsetForExportButton(inputGroup,inputPosition);if(inputPosition.align==="left"){translateX=plotLeft}else if(inputPosition.align==="right"){translateX=-Math.max(chart.axisOffset[1],-xOffsetForExportButton)}inputGroup.align({y:inputPosition.y,width:inputGroup.getBBox().width,align:inputPosition.align,x:inputPosition.x+translateX-2},true,chart.spacingBox);inputGroup.placed=chart.hasLoaded}this.handleCollision(xOffsetForExportButton);group.align({verticalAlign:verticalAlign},true,chart.spacingBox);const alignTranslateY=group.alignAttr.translateY;let groupHeight=group.getBBox().height+20;let translateY=0;if(verticalAlign==="bottom"){const legendOptions=chart.legend&&chart.legend.options;const legendHeight=legendOptions&&legendOptions.verticalAlign==="bottom"&&legendOptions.enabled&&!legendOptions.floating?chart.legend.legendHeight+RangeSelector_pick(legendOptions.margin,10):0;groupHeight=groupHeight+legendHeight-20;translateY=alignTranslateY-groupHeight-(options.floating?0:options.y)-(chart.titleOffset?chart.titleOffset[2]:0)-10}if(verticalAlign==="top"){if(options.floating){translateY=0}if(chart.titleOffset&&chart.titleOffset[0]){translateY=chart.titleOffset[0]}translateY+=chart.margin[0]-chart.spacing[0]||0}else if(verticalAlign==="middle"){if(inputPosition.y===buttonPosition.y){translateY=alignTranslateY}else if(inputPosition.y||buttonPosition.y){if(inputPosition.y<0||buttonPosition.y<0){translateY-=Math.min(inputPosition.y,buttonPosition.y)}else{translateY=alignTranslateY-groupHeight}}}group.translate(options.x,options.y+Math.floor(translateY));const{minInput,maxInput,dropdown}=this;if(options.inputEnabled&&minInput&&maxInput){minInput.style.marginTop=group.translateY+"px";maxInput.style.marginTop=group.translateY+"px"}if(dropdown){dropdown.style.marginTop=group.translateY+"px"}}}redrawElements(){const chart=this.chart,{inputBoxHeight,inputBoxBorderColor}=this.options;this.maxDateBox?.attr({height:inputBoxHeight});this.minDateBox?.attr({height:inputBoxHeight});if(!chart.styledMode){this.maxDateBox?.attr({stroke:inputBoxBorderColor});this.minDateBox?.attr({stroke:inputBoxBorderColor})}if(this.isDirty){this.isDirty=false;this.isCollapsed=void 0;const newButtonsOptions=this.options.buttons??[];const btnLength=Math.min(newButtonsOptions.length,this.buttonOptions.length);const{dropdown,options}=this;const buttonTheme=RangeSelector_merge(options.buttonTheme);const states=buttonTheme&&buttonTheme.states;const width=buttonTheme.width||28;if(newButtonsOptions.length<this.buttonOptions.length){for(let i=this.buttonOptions.length-1;i>=newButtonsOptions.length;i--){const btn=this.buttons.pop();btn?.destroy();this.dropdown?.options.remove(i+1)}}for(let i=btnLength-1;i>=0;i--){const diff=diffObjects(newButtonsOptions[i],this.buttonOptions[i]);if(Object.keys(diff).length!==0){const rangeOptions=newButtonsOptions[i];this.buttons[i].destroy();dropdown?.options.remove(i+1);this.createButton(rangeOptions,i,width,states);this.computeButtonRange(rangeOptions)}}if(newButtonsOptions.length>this.buttonOptions.length){for(let i=this.buttonOptions.length;i<newButtonsOptions.length;i++){this.createButton(newButtonsOptions[i],i,width,states);this.computeButtonRange(newButtonsOptions[i])}}this.buttonOptions=this.options.buttons??[];if(RangeSelector_defined(this.options.selected)&&this.buttons.length){this.clickButton(this.options.selected,false)}}}alignButtonGroup(xOffsetForExportButton,width){const{chart,options,buttonGroup}=this;const{buttonPosition}=options;const plotLeft=chart.plotLeft-chart.spacing[3];let translateX=buttonPosition.x-chart.spacing[3];if(buttonPosition.align==="right"){translateX+=xOffsetForExportButton-plotLeft}else if(buttonPosition.align==="center"){translateX-=plotLeft/2}if(buttonGroup){buttonGroup.align({y:buttonPosition.y,width:RangeSelector_pick(width,this.initialButtonGroupWidth),align:buttonPosition.align,x:translateX},true,chart.spacingBox)}}positionButtons(){const{buttons,chart,options,zoomText}=this;const verb=chart.hasLoaded?"animate":"attr";const{buttonPosition}=options;const plotLeft=chart.plotLeft;let buttonLeft=plotLeft;if(zoomText&&zoomText.visibility!=="hidden"){zoomText[verb]({x:RangeSelector_pick(plotLeft+buttonPosition.x,plotLeft)});buttonLeft+=buttonPosition.x+zoomText.getBBox().width+5}for(let i=0,iEnd=this.buttonOptions.length;i<iEnd;++i){if(buttons[i].visibility!=="hidden"){buttons[i][verb]({x:buttonLeft});buttonLeft+=(buttons[i].width||0)+options.buttonSpacing}else{buttons[i][verb]({x:plotLeft})}}}handleCollision(xOffsetForExportButton){const{chart,buttonGroup,inputGroup}=this;const{buttonPosition,dropdown,inputPosition}=this.options;const maxButtonWidth=()=>{let buttonWidth=0;this.buttons.forEach(button=>{const bBox=button.getBBox();if(bBox.width>buttonWidth){buttonWidth=bBox.width}});return buttonWidth};const groupsOverlap=buttonGroupWidth=>{if(inputGroup?.alignOptions&&buttonGroup){const inputGroupX=inputGroup.alignAttr.translateX+inputGroup.alignOptions.x-xOffsetForExportButton+inputGroup.getBBox().x+2;const inputGroupWidth=inputGroup.alignOptions.width||0;const buttonGroupX=buttonGroup.alignAttr.translateX+buttonGroup.getBBox().x;return buttonGroupX+buttonGroupWidth>inputGroupX&&inputGroupX+inputGroupWidth>buttonGroupX&&buttonPosition.y<inputPosition.y+inputGroup.getBBox().height}return false};const moveInputsDown=()=>{if(inputGroup&&buttonGroup){inputGroup.attr({translateX:inputGroup.alignAttr.translateX+(chart.axisOffset[1]>=-xOffsetForExportButton?0:-xOffsetForExportButton),translateY:inputGroup.alignAttr.translateY+buttonGroup.getBBox().height+10})}};if(buttonGroup){if(dropdown==="always"){this.collapseButtons();if(groupsOverlap(maxButtonWidth())){moveInputsDown()}return}if(dropdown==="never"){this.expandButtons()}}if(inputGroup&&buttonGroup){if(inputPosition.align===buttonPosition.align||groupsOverlap(this.initialButtonGroupWidth+20)){if(dropdown==="responsive"){this.collapseButtons();if(groupsOverlap(maxButtonWidth())){moveInputsDown()}}else{moveInputsDown()}}else if(dropdown==="responsive"){this.expandButtons()}}else if(buttonGroup&&dropdown==="responsive"){if(this.initialButtonGroupWidth>chart.plotWidth){this.collapseButtons()}else{this.expandButtons()}}}collapseButtons(){const{buttons,zoomText}=this;if(this.isCollapsed===true){return}this.isCollapsed=true;zoomText.hide();buttons.forEach(button=>void button.hide());this.showDropdown()}expandButtons(){const{buttons,zoomText}=this;if(this.isCollapsed===false){return}this.isCollapsed=false;this.hideDropdown();zoomText.show();buttons.forEach(button=>void button.show());this.positionButtons()}showDropdown(){const{buttonGroup,chart,dropdownLabel,dropdown}=this;if(buttonGroup&&dropdown){const{translateX=0,translateY=0}=buttonGroup,left=chart.plotLeft+translateX,top=translateY;dropdownLabel.attr({x:left,y:top}).show();RangeSelector_css(dropdown,{left:left+"px",top:top+"px",visibility:"inherit"});this.hasVisibleDropdown=true}}hideDropdown(){const{dropdown}=this;if(dropdown){this.dropdownLabel.hide();RangeSelector_css(dropdown,{visibility:"hidden",width:"1px",height:"1px"});this.hasVisibleDropdown=false}}getHeight(){const rangeSelector=this,options=rangeSelector.options,rangeSelectorGroup=rangeSelector.group,inputPosition=options.inputPosition,buttonPosition=options.buttonPosition,yPosition=options.y,buttonPositionY=buttonPosition.y,inputPositionY=inputPosition.y;let rangeSelectorHeight=0;if(options.height){return options.height}this.alignElements();rangeSelectorHeight=rangeSelectorGroup?rangeSelectorGroup.getBBox(true).height+13+yPosition:0;const minPosition=Math.min(inputPositionY,buttonPositionY);if(inputPositionY<0&&buttonPositionY<0||inputPositionY>0&&buttonPositionY>0){rangeSelectorHeight+=Math.abs(minPosition)}return rangeSelectorHeight}titleCollision(chart){return!(chart.options.title.text||chart.options.subtitle.text)}update(options,redraw=true){const chart=this.chart;RangeSelector_merge(true,this.options,options);if(this.options.selected&&this.options.selected>=this.options.buttons.length){this.options.selected=void 0;chart.options.rangeSelector.selected=void 0}if(RangeSelector_defined(options.enabled)){this.destroy();return this.init(chart)}this.isDirty=!!options.buttons;if(redraw){this.render()}}destroy(){const rSelector=this,minInput=rSelector.minInput,maxInput=rSelector.maxInput;if(rSelector.eventsToUnbind){rSelector.eventsToUnbind.forEach(unbind=>unbind());rSelector.eventsToUnbind=void 0}RangeSelector_destroyObjectProperties(rSelector.buttons);if(minInput){minInput.onfocus=minInput.onblur=minInput.onchange=null}if(maxInput){maxInput.onfocus=maxInput.onblur=maxInput.onchange=null}RangeSelector_objectEach(rSelector,function(val,key){if(val&&key!=="chart"){if(val instanceof highcharts_SVGElement_commonjs_highcharts_SVGElement_commonjs2_highcharts_SVGElement_root_Highcharts_SVGElement_default()){val.destroy()}else if(val instanceof window.HTMLElement){discardElement(val)}delete rSelector[key]}if(val!==RangeSelector.prototype[key]){rSelector[key]=null}},this);this.buttons=[]}}RangeSelector_extend(RangeSelector.prototype,{inputTypeFormats:{"datetime-local":"%Y-%m-%dT%H:%M:%S",date:"%Y-%m-%d",time:"%H:%M:%S"}});const RangeSelector_RangeSelector=RangeSelector;"";const getLinkPath={default:getDefaultPath,straight:getStraightPath,curved:getCurvedPath};function getDefaultPath(pathParams){const{x1,y1,x2,y2,width=0,inverted=false,radius,parentVisible}=pathParams;const path=[["M",x1,y1],["L",x1,y1],["C",x1,y1,x1,y2,x1,y2],["L",x1,y2],["C",x1,y1,x1,y2,x1,y2],["L",x1,y2]];return parentVisible?applyRadius([["M",x1,y1],["L",x1+width*(inverted?-.5:.5),y1],["L",x1+width*(inverted?-.5:.5),y2],["L",x2,y2]],radius):path}function getStraightPath(pathParams){const{x1,y1,x2,y2,width=0,inverted=false,parentVisible}=pathParams;return parentVisible?[["M",x1,y1],["L",x1+width*(inverted?-1:1),y2],["L",x2,y2]]:[["M",x1,y1],["L",x1,y2],["L",x1,y2]]}function getCurvedPath(pathParams){const{x1,y1,x2,y2,offset=0,width=0,inverted=false,parentVisible}=pathParams;return parentVisible?[["M",x1,y1],["C",x1+offset,y1,x1-offset+width*(inverted?-1:1),y2,x1+width*(inverted?-1:1),y2],["L",x2,y2]]:[["M",x1,y1],["C",x1,y1,x1,y2,x1,y2],["L",x2,y2]]}function applyRadius(path,r){const d=[];for(let i=0;i<path.length;i++){const x=path[i][1];const y=path[i][2];if(typeof x==="number"&&typeof y==="number"){if(i===0){d.push(["M",x,y])}else if(i===path.length-1){d.push(["L",x,y])}else if(r){const prevSeg=path[i-1];const nextSeg=path[i+1];if(prevSeg&&nextSeg){const x1=prevSeg[1],y1=prevSeg[2],x2=nextSeg[1],y2=nextSeg[2];if(typeof x1==="number"&&typeof x2==="number"&&typeof y1==="number"&&typeof y2==="number"&&x1!==x2&&y1!==y2){const directionX=x1<x2?1:-1,directionY=y1<y2?1:-1;d.push(["L",x-directionX*Math.min(Math.abs(x-x1),r),y-directionY*Math.min(Math.abs(y-y1),r)],["C",x,y,x,y,x+directionX*Math.min(Math.abs(x-x2),r),y+directionY*Math.min(Math.abs(y-y2),r)])}}}else{d.push(["L",x,y])}}}return d}const PathUtilities={applyRadius:applyRadius,getLinkPath:getLinkPath};const Series_PathUtilities=PathUtilities;const{pick:PathfinderAlgorithms_pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{min:PathfinderAlgorithms_min,max:PathfinderAlgorithms_max,abs}=Math;function findLastObstacleBefore(obstacles,xMin,startIx){const min=xMin-1e-7;let left=startIx||0,right=obstacles.length-1,cursor,cmp;while(left<=right){cursor=right+left>>1;cmp=min-obstacles[cursor].xMin;if(cmp>0){left=cursor+1}else if(cmp<0){right=cursor-1}else{return cursor}}return left>0?left-1:0}function pointWithinObstacle(obstacle,point){return point.x<=obstacle.xMax&&point.x>=obstacle.xMin&&point.y<=obstacle.yMax&&point.y>=obstacle.yMin}function findObstacleFromPoint(obstacles,point){let i=findLastObstacleBefore(obstacles,point.x+1)+1;while(i--){if(obstacles[i].xMax>=point.x&&pointWithinObstacle(obstacles[i],point)){return i}}return-1}function pathFromSegments(segments){const path=[];if(segments.length){path.push(["M",segments[0].start.x,segments[0].start.y]);for(let i=0;i<segments.length;++i){path.push(["L",segments[i].end.x,segments[i].end.y])}}return path}function limitObstacleToBounds(obstacle,bounds){obstacle.yMin=PathfinderAlgorithms_max(obstacle.yMin,bounds.yMin);obstacle.yMax=PathfinderAlgorithms_min(obstacle.yMax,bounds.yMax);obstacle.xMin=PathfinderAlgorithms_max(obstacle.xMin,bounds.xMin);obstacle.xMax=PathfinderAlgorithms_min(obstacle.xMax,bounds.xMax)}function straight(start,end){return{path:[["M",start.x,start.y],["L",end.x,end.y]],obstacles:[{start:start,end:end}]}}const simpleConnect=function(start,end,options){const segments=[],chartObstacles=options.chartObstacles,startObstacleIx=findObstacleFromPoint(chartObstacles,start),endObstacleIx=findObstacleFromPoint(chartObstacles,end);let endSegment,dir=PathfinderAlgorithms_pick(options.startDirectionX,abs(end.x-start.x)>abs(end.y-start.y))?"x":"y",startObstacle,endObstacle,waypoint,useMax,endPoint;function copyFromPoint(from,fromKey,to,toKey,offset){const point={x:from.x,y:from.y};point[fromKey]=to[toKey||fromKey]+(offset||0);return point}function getMeOut(obstacle,point,direction){const useMax=abs(point[direction]-obstacle[direction+"Min"])>abs(point[direction]-obstacle[direction+"Max"]);return copyFromPoint(point,direction,obstacle,direction+(useMax?"Max":"Min"),useMax?1:-1)}if(endObstacleIx>-1){endObstacle=chartObstacles[endObstacleIx];waypoint=getMeOut(endObstacle,end,dir);endSegment={start:waypoint,end:end};endPoint=waypoint}else{endPoint=end}if(startObstacleIx>-1){startObstacle=chartObstacles[startObstacleIx];waypoint=getMeOut(startObstacle,start,dir);segments.push({start:start,end:waypoint});if(waypoint[dir]>=start[dir]===waypoint[dir]>=endPoint[dir]){dir=dir==="y"?"x":"y";useMax=start[dir]<end[dir];segments.push({start:waypoint,end:copyFromPoint(waypoint,dir,startObstacle,dir+(useMax?"Max":"Min"),useMax?1:-1)});dir=dir==="y"?"x":"y"}}const prevWaypoint=segments.length?segments[segments.length-1].end:start;waypoint=copyFromPoint(prevWaypoint,dir,endPoint);segments.push({start:prevWaypoint,end:waypoint});dir=dir==="y"?"x":"y";const waypoint2=copyFromPoint(waypoint,dir,endPoint);segments.push({start:waypoint,end:waypoint2});segments.push(endSegment);const path=Series_PathUtilities.applyRadius(pathFromSegments(segments),options.radius);return{path:path,obstacles:segments}};simpleConnect.requiresObstacles=true;function fastAvoid(start,end,options){const dirIsX=PathfinderAlgorithms_pick(options.startDirectionX,abs(end.x-start.x)>abs(end.y-start.y)),dir=dirIsX?"x":"y",endSegments=[],metrics=options.obstacleMetrics,softMinX=PathfinderAlgorithms_min(start.x,end.x)-metrics.maxWidth-10,softMaxX=PathfinderAlgorithms_max(start.x,end.x)+metrics.maxWidth+10,softMinY=PathfinderAlgorithms_min(start.y,end.y)-metrics.maxHeight-10,softMaxY=PathfinderAlgorithms_max(start.y,end.y)+metrics.maxHeight+10;let segments,useMax,extractedEndPoint,forceObstacleBreak=false,chartObstacles=options.chartObstacles,endObstacleIx=findLastObstacleBefore(chartObstacles,softMaxX);const startObstacleIx=findLastObstacleBefore(chartObstacles,softMinX);function pivotPoint(fromPoint,toPoint,directionIsX){const searchDirection=fromPoint.x<toPoint.x?1:-1;let firstPoint,lastPoint,highestPoint,lowestPoint;if(fromPoint.x<toPoint.x){firstPoint=fromPoint;lastPoint=toPoint}else{firstPoint=toPoint;lastPoint=fromPoint}if(fromPoint.y<toPoint.y){lowestPoint=fromPoint;highestPoint=toPoint}else{lowestPoint=toPoint;highestPoint=fromPoint}let i=searchDirection<0?PathfinderAlgorithms_min(findLastObstacleBefore(chartObstacles,lastPoint.x),chartObstacles.length-1):0;while(chartObstacles[i]&&(searchDirection>0&&chartObstacles[i].xMin<=lastPoint.x||searchDirection<0&&chartObstacles[i].xMax>=firstPoint.x)){if(chartObstacles[i].xMin<=lastPoint.x&&chartObstacles[i].xMax>=firstPoint.x&&chartObstacles[i].yMin<=highestPoint.y&&chartObstacles[i].yMax>=lowestPoint.y){if(directionIsX){return{y:fromPoint.y,x:fromPoint.x<toPoint.x?chartObstacles[i].xMin-1:chartObstacles[i].xMax+1,obstacle:chartObstacles[i]}}return{x:fromPoint.x,y:fromPoint.y<toPoint.y?chartObstacles[i].yMin-1:chartObstacles[i].yMax+1,obstacle:chartObstacles[i]}}i+=searchDirection}return toPoint}function getDodgeDirection(obstacle,fromPoint,toPoint,dirIsX,bounds){const softBounds=bounds.soft,hardBounds=bounds.hard,dir=dirIsX?"x":"y",toPointMax={x:fromPoint.x,y:fromPoint.y},toPointMin={x:fromPoint.x,y:fromPoint.y},maxOutOfSoftBounds=obstacle[dir+"Max"]>=softBounds[dir+"Max"],minOutOfSoftBounds=obstacle[dir+"Min"]<=softBounds[dir+"Min"],maxOutOfHardBounds=obstacle[dir+"Max"]>=hardBounds[dir+"Max"],minOutOfHardBounds=obstacle[dir+"Min"]<=hardBounds[dir+"Min"],minDistance=abs(obstacle[dir+"Min"]-fromPoint[dir]),maxDistance=abs(obstacle[dir+"Max"]-fromPoint[dir]);let useMax=abs(minDistance-maxDistance)<10?fromPoint[dir]<toPoint[dir]:maxDistance<minDistance;toPointMin[dir]=obstacle[dir+"Min"];toPointMax[dir]=obstacle[dir+"Max"];const minPivot=pivotPoint(fromPoint,toPointMin,dirIsX)[dir]!==toPointMin[dir],maxPivot=pivotPoint(fromPoint,toPointMax,dirIsX)[dir]!==toPointMax[dir];useMax=minPivot?maxPivot?useMax:true:maxPivot?false:useMax;useMax=minOutOfSoftBounds?maxOutOfSoftBounds?useMax:true:maxOutOfSoftBounds?false:useMax;useMax=minOutOfHardBounds?maxOutOfHardBounds?useMax:true:maxOutOfHardBounds?false:useMax;return useMax}function clearPathTo(fromPoint,toPoint,dirIsX){if(fromPoint.x===toPoint.x&&fromPoint.y===toPoint.y){return[]}const dir=dirIsX?"x":"y",obstacleMargin=options.obstacleOptions.margin,bounds={soft:{xMin:softMinX,xMax:softMaxX,yMin:softMinY,yMax:softMaxY},hard:options.hardBounds};let pivot,segments,waypoint,waypointUseMax,envelopingObstacle,secondEnvelopingObstacle,envelopWaypoint;envelopingObstacle=findObstacleFromPoint(chartObstacles,fromPoint);if(envelopingObstacle>-1){envelopingObstacle=chartObstacles[envelopingObstacle];waypointUseMax=getDodgeDirection(envelopingObstacle,fromPoint,toPoint,dirIsX,bounds);limitObstacleToBounds(envelopingObstacle,options.hardBounds);envelopWaypoint=dirIsX?{y:fromPoint.y,x:envelopingObstacle[waypointUseMax?"xMax":"xMin"]+(waypointUseMax?1:-1)}:{x:fromPoint.x,y:envelopingObstacle[waypointUseMax?"yMax":"yMin"]+(waypointUseMax?1:-1)};secondEnvelopingObstacle=findObstacleFromPoint(chartObstacles,envelopWaypoint);if(secondEnvelopingObstacle>-1){secondEnvelopingObstacle=chartObstacles[secondEnvelopingObstacle];limitObstacleToBounds(secondEnvelopingObstacle,options.hardBounds);envelopWaypoint[dir]=waypointUseMax?PathfinderAlgorithms_max(envelopingObstacle[dir+"Max"]-obstacleMargin+1,(secondEnvelopingObstacle[dir+"Min"]+envelopingObstacle[dir+"Max"])/2):PathfinderAlgorithms_min(envelopingObstacle[dir+"Min"]+obstacleMargin-1,(secondEnvelopingObstacle[dir+"Max"]+envelopingObstacle[dir+"Min"])/2);if(fromPoint.x===envelopWaypoint.x&&fromPoint.y===envelopWaypoint.y){if(forceObstacleBreak){envelopWaypoint[dir]=waypointUseMax?PathfinderAlgorithms_max(envelopingObstacle[dir+"Max"],secondEnvelopingObstacle[dir+"Max"])+1:PathfinderAlgorithms_min(envelopingObstacle[dir+"Min"],secondEnvelopingObstacle[dir+"Min"])-1}forceObstacleBreak=!forceObstacleBreak}else{forceObstacleBreak=false}}segments=[{start:fromPoint,end:envelopWaypoint}]}else{pivot=pivotPoint(fromPoint,{x:dirIsX?toPoint.x:fromPoint.x,y:dirIsX?fromPoint.y:toPoint.y},dirIsX);segments=[{start:fromPoint,end:{x:pivot.x,y:pivot.y}}];if(pivot[dirIsX?"x":"y"]!==toPoint[dirIsX?"x":"y"]){waypointUseMax=getDodgeDirection(pivot.obstacle,pivot,toPoint,!dirIsX,bounds);limitObstacleToBounds(pivot.obstacle,options.hardBounds);waypoint={x:dirIsX?pivot.x:pivot.obstacle[waypointUseMax?"xMax":"xMin"]+(waypointUseMax?1:-1),y:dirIsX?pivot.obstacle[waypointUseMax?"yMax":"yMin"]+(waypointUseMax?1:-1):pivot.y};dirIsX=!dirIsX;segments=segments.concat(clearPathTo({x:pivot.x,y:pivot.y},waypoint,dirIsX))}}segments=segments.concat(clearPathTo(segments[segments.length-1].end,toPoint,!dirIsX));return segments}function extractFromObstacle(obstacle,point,goalPoint){const dirIsX=PathfinderAlgorithms_min(obstacle.xMax-point.x,point.x-obstacle.xMin)<PathfinderAlgorithms_min(obstacle.yMax-point.y,point.y-obstacle.yMin),bounds={soft:options.hardBounds,hard:options.hardBounds},useMax=getDodgeDirection(obstacle,point,goalPoint,dirIsX,bounds);return dirIsX?{y:point.y,x:obstacle[useMax?"xMax":"xMin"]+(useMax?1:-1)}:{x:point.x,y:obstacle[useMax?"yMax":"yMin"]+(useMax?1:-1)}}chartObstacles=chartObstacles.slice(startObstacleIx,endObstacleIx+1);if((endObstacleIx=findObstacleFromPoint(chartObstacles,end))>-1){extractedEndPoint=extractFromObstacle(chartObstacles[endObstacleIx],end,start);endSegments.push({end:end,start:extractedEndPoint});end=extractedEndPoint}while((endObstacleIx=findObstacleFromPoint(chartObstacles,end))>-1){useMax=end[dir]-start[dir]<0;extractedEndPoint={x:end.x,y:end.y};extractedEndPoint[dir]=chartObstacles[endObstacleIx][useMax?dir+"Max":dir+"Min"]+(useMax?1:-1);endSegments.push({end:end,start:extractedEndPoint});end=extractedEndPoint}segments=clearPathTo(start,end,dirIsX);segments=segments.concat(endSegments.reverse());return{path:pathFromSegments(segments),obstacles:segments}}fastAvoid.requiresObstacles=true;const algorithms={fastAvoid:fastAvoid,straight:straight,simpleConnect:simpleConnect};const PathfinderAlgorithms=algorithms;const connectorsDefaults={connectors:{type:"straight",radius:0,lineWidth:1,marker:{enabled:false,align:"center",verticalAlign:"middle",inside:false,lineWidth:1},startMarker:{symbol:"diamond"},endMarker:{symbol:"arrow-filled"}}};const ConnectorsDefaults=connectorsDefaults;"";const{setOptions:PathfinderComposition_setOptions}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{defined:PathfinderComposition_defined,error:PathfinderComposition_error,merge:PathfinderComposition_merge}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function getPointBB(point){const shapeArgs=point.shapeArgs;if(shapeArgs){return{xMin:shapeArgs.x||0,xMax:(shapeArgs.x||0)+(shapeArgs.width||0),yMin:shapeArgs.y||0,yMax:(shapeArgs.y||0)+(shapeArgs.height||0)}}const bb=point.graphic&&point.graphic.getBBox();return bb?{xMin:point.plotX-bb.width/2,xMax:point.plotX+bb.width/2,yMin:point.plotY-bb.height/2,yMax:point.plotY+bb.height/2}:null}function warnLegacy(chart){if(chart.options.pathfinder||chart.series.reduce(function(acc,series){if(series.options){PathfinderComposition_merge(true,series.options.connectors=series.options.connectors||{},series.options.pathfinder)}return acc||series.options&&series.options.pathfinder},false)){PathfinderComposition_merge(true,chart.options.connectors=chart.options.connectors||{},chart.options.pathfinder);PathfinderComposition_error("WARNING: Pathfinder options have been renamed. "+'Use "chart.connectors" or "series.connectors" instead.')}}var ConnectionComposition;(function(ConnectionComposition){function compose(ChartClass,PathfinderClass,PointClass){const pointProto=PointClass.prototype;if(!pointProto.getPathfinderAnchorPoint){ChartClass.prototype.callbacks.push(function(chart){const options=chart.options;if(options.connectors.enabled!==false){warnLegacy(chart);this.pathfinder=new PathfinderClass(this);this.pathfinder.update(true)}});pointProto.getMarkerVector=pointGetMarkerVector;pointProto.getPathfinderAnchorPoint=pointGetPathfinderAnchorPoint;pointProto.getRadiansToVector=pointGetRadiansToVector;PathfinderComposition_setOptions(ConnectorsDefaults)}}ConnectionComposition.compose=compose;function pointGetPathfinderAnchorPoint(markerOptions){const bb=getPointBB(this);let x,y;switch(markerOptions.align){case"right":x="xMax";break;case"left":x="xMin"}switch(markerOptions.verticalAlign){case"top":y="yMin";break;case"bottom":y="yMax"}return{x:x?bb[x]:(bb.xMin+bb.xMax)/2,y:y?bb[y]:(bb.yMin+bb.yMax)/2}}function pointGetRadiansToVector(v1,v2){let box;if(!PathfinderComposition_defined(v2)){box=getPointBB(this);if(box){v2={x:(box.xMin+box.xMax)/2,y:(box.yMin+box.yMax)/2}}}return Math.atan2(v2.y-v1.y,v1.x-v2.x)}function pointGetMarkerVector(radians,markerRadius,anchor){const twoPI=Math.PI*2,bb=getPointBB(this),rectWidth=bb.xMax-bb.xMin,rectHeight=bb.yMax-bb.yMin,rAtan=Math.atan2(rectHeight,rectWidth),rectHalfWidth=rectWidth/2,rectHalfHeight=rectHeight/2,rectHorizontalCenter=bb.xMin+rectHalfWidth,rectVerticalCenter=bb.yMin+rectHalfHeight,edgePoint={x:rectHorizontalCenter,y:rectVerticalCenter};let theta=radians,tanTheta=1,leftOrRightRegion=false,xFactor=1,yFactor=1;while(theta<-Math.PI){theta+=twoPI}while(theta>Math.PI){theta-=twoPI}tanTheta=Math.tan(theta);if(theta>-rAtan&&theta<=rAtan){yFactor=-1;leftOrRightRegion=true}else if(theta>rAtan&&theta<=Math.PI-rAtan){yFactor=-1}else if(theta>Math.PI-rAtan||theta<=-(Math.PI-rAtan)){xFactor=-1;leftOrRightRegion=true}else{xFactor=-1}if(leftOrRightRegion){edgePoint.x+=xFactor*rectHalfWidth;edgePoint.y+=yFactor*rectHalfWidth*tanTheta}else{edgePoint.x+=xFactor*(rectHeight/(2*tanTheta));edgePoint.y+=yFactor*rectHalfHeight}if(anchor.x!==rectHorizontalCenter){edgePoint.x=anchor.x}if(anchor.y!==rectVerticalCenter){edgePoint.y=anchor.y}return{x:edgePoint.x+markerRadius*Math.cos(theta),y:edgePoint.y-markerRadius*Math.sin(theta)}}})(ConnectionComposition||(ConnectionComposition={}));const PathfinderComposition=ConnectionComposition;var highcharts_Point_commonjs_highcharts_Point_commonjs2_highcharts_Point_root_Highcharts_Point_=__webpack_require__(260);var highcharts_Point_commonjs_highcharts_Point_commonjs2_highcharts_Point_root_Highcharts_Point_default=__webpack_require__.n(highcharts_Point_commonjs_highcharts_Point_commonjs2_highcharts_Point_root_Highcharts_Point_);const{addEvent:Pathfinder_addEvent,defined:Pathfinder_defined,pick:Pathfinder_pick,splat:Pathfinder_splat}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const Pathfinder_max=Math.max,Pathfinder_min=Math.min;function Pathfinder_getPointBB(point){const shapeArgs=point.shapeArgs;if(shapeArgs){return{xMin:shapeArgs.x||0,xMax:(shapeArgs.x||0)+(shapeArgs.width||0),yMin:shapeArgs.y||0,yMax:(shapeArgs.y||0)+(shapeArgs.height||0)}}const bb=point.graphic&&point.graphic.getBBox();return bb?{xMin:point.plotX-bb.width/2,xMax:point.plotX+bb.width/2,yMin:point.plotY-bb.height/2,yMax:point.plotY+bb.height/2}:null}function calculateObstacleDistance(a,b,bbMargin){const margin=Pathfinder_pick(bbMargin,10),yOverlap=a.yMax+margin>b.yMin-margin&&a.yMin-margin<b.yMax+margin,xOverlap=a.xMax+margin>b.xMin-margin&&a.xMin-margin<b.xMax+margin,xDistance=yOverlap?a.xMin>b.xMax?a.xMin-b.xMax:b.xMin-a.xMax:Infinity,yDistance=xOverlap?a.yMin>b.yMax?a.yMin-b.yMax:b.yMin-a.yMax:Infinity;if(xOverlap&&yOverlap){return margin?calculateObstacleDistance(a,b,Math.floor(margin/2)):Infinity}return Pathfinder_min(xDistance,yDistance)}function calculateObstacleMargin(obstacles){const len=obstacles.length,distances=[];let onstacleDistance;for(let i=0;i<len;++i){for(let j=i+1;j<len;++j){onstacleDistance=calculateObstacleDistance(obstacles[i],obstacles[j]);if(onstacleDistance<80){distances.push(onstacleDistance)}}}distances.push(80);return Pathfinder_max(Math.floor(distances.sort(function(a,b){return a-b})[Math.floor(distances.length/10)]/2-1),1)}class Pathfinder{static compose(ChartClass,PointClass){PathfinderComposition.compose(ChartClass,Pathfinder,PointClass)}constructor(chart){this.init(chart)}init(chart){this.chart=chart;this.connections=[];Pathfinder_addEvent(chart,"redraw",function(){this.pathfinder.update()})}update(deferRender){const chart=this.chart,pathfinder=this,oldConnections=pathfinder.connections;pathfinder.connections=[];chart.series.forEach(function(series){if(series.visible&&!series.options.isInternal){series.points.forEach(function(point){const ganttPointOptions=point.options;if(ganttPointOptions&&ganttPointOptions.dependency){ganttPointOptions.connect=ganttPointOptions.dependency}const connects=point.options?.connect?Pathfinder_splat(point.options.connect):[];let to;if(point.visible&&point.isInside!==false){connects.forEach(connect=>{const toId=typeof connect==="string"?connect:connect.to;if(toId){to=chart.get(toId)}if(to instanceof highcharts_Point_commonjs_highcharts_Point_commonjs2_highcharts_Point_root_Highcharts_Point_default()&&to.series.visible&&to.visible&&to.isInside!==false){pathfinder.connections.push(new Gantt_Connection(point,to,typeof connect==="string"?{}:connect))}})}})}});for(let j=0,k,found,lenOld=oldConnections.length,lenNew=pathfinder.connections.length;j<lenOld;++j){found=false;const oldCon=oldConnections[j];for(k=0;k<lenNew;++k){const newCon=pathfinder.connections[k];if((oldCon.options&&oldCon.options.type)===(newCon.options&&newCon.options.type)&&oldCon.fromPoint===newCon.fromPoint&&oldCon.toPoint===newCon.toPoint){newCon.graphics=oldCon.graphics;found=true;break}}if(!found){oldCon.destroy()}}delete this.chartObstacles;delete this.lineObstacles;pathfinder.renderConnections(deferRender)}renderConnections(deferRender){if(deferRender){this.chart.series.forEach(function(series){const render=function(){const pathfinder=series.chart.pathfinder,conns=pathfinder&&pathfinder.connections||[];conns.forEach(function(connection){if(connection.fromPoint&&connection.fromPoint.series===series){connection.render()}});if(series.pathfinderRemoveRenderEvent){series.pathfinderRemoveRenderEvent();delete series.pathfinderRemoveRenderEvent}};if(series.options.animation===false){render()}else{series.pathfinderRemoveRenderEvent=Pathfinder_addEvent(series,"afterAnimate",render)}})}else{this.connections.forEach(function(connection){connection.render()})}}getChartObstacles(options){const series=this.chart.series,margin=Pathfinder_pick(options.algorithmMargin,0);let obstacles=[],calculatedMargin;for(let i=0,sLen=series.length;i<sLen;++i){if(series[i].visible&&!series[i].options.isInternal){for(let j=0,pLen=series[i].points.length,bb,point;j<pLen;++j){point=series[i].points[j];if(point.visible){bb=Pathfinder_getPointBB(point);if(bb){obstacles.push({xMin:bb.xMin-margin,xMax:bb.xMax+margin,yMin:bb.yMin-margin,yMax:bb.yMax+margin})}}}}}obstacles=obstacles.sort(function(a,b){return a.xMin-b.xMin});if(!Pathfinder_defined(options.algorithmMargin)){calculatedMargin=options.algorithmMargin=calculateObstacleMargin(obstacles);obstacles.forEach(function(obstacle){obstacle.xMin-=calculatedMargin;obstacle.xMax+=calculatedMargin;obstacle.yMin-=calculatedMargin;obstacle.yMax+=calculatedMargin})}return obstacles}getObstacleMetrics(obstacles){let maxWidth=0,maxHeight=0,width,height,i=obstacles.length;while(i--){width=obstacles[i].xMax-obstacles[i].xMin;height=obstacles[i].yMax-obstacles[i].yMin;if(maxWidth<width){maxWidth=width}if(maxHeight<height){maxHeight=height}}return{maxHeight:maxHeight,maxWidth:maxWidth}}getAlgorithmStartDirection(markerOptions){const xCenter=markerOptions.align!=="left"&&markerOptions.align!=="right",yCenter=markerOptions.verticalAlign!=="top"&&markerOptions.verticalAlign!=="bottom";return xCenter?yCenter?void 0:false:yCenter?true:void 0}}Pathfinder.prototype.algorithms=PathfinderAlgorithms;const Gantt_Pathfinder=Pathfinder;"";const G=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();G.Pathfinder=G.Pathfinder||Gantt_Pathfinder;Extensions_ArrowSymbols.compose(G.SVGRenderer);G.Pathfinder.compose(G.Chart,G.Point);const pathfinder_src=null&&Highcharts;const{addEvent:StaticScale_addEvent,defined:StaticScale_defined,isNumber:StaticScale_isNumber,pick:StaticScale_pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function StaticScale_compose(AxisClass,ChartClass){const chartProto=ChartClass.prototype;if(!chartProto.adjustHeight){StaticScale_addEvent(AxisClass,"afterSetOptions",StaticScale_onAxisAfterSetOptions);chartProto.adjustHeight=chartAdjustHeight;StaticScale_addEvent(ChartClass,"render",chartProto.adjustHeight)}}function StaticScale_onAxisAfterSetOptions(){const chartOptions=this.chart.options.chart;if(!this.horiz&&StaticScale_isNumber(this.options.staticScale)&&(!chartOptions.height||chartOptions.scrollablePlotArea&&chartOptions.scrollablePlotArea.minHeight)){this.staticScale=this.options.staticScale}}function chartAdjustHeight(){const chart=this;if(chart.redrawTrigger!=="adjustHeight"){for(const axis of chart.axes||[]){const chart=axis.chart,animate=!!chart.initiatedScale&&chart.options.animation,staticScale=axis.options.staticScale;if(axis.staticScale&&StaticScale_defined(axis.min)){let height=StaticScale_pick(axis.brokenAxis&&axis.brokenAxis.unitLength,axis.max+axis.tickInterval-axis.min)*staticScale;height=Math.max(height,staticScale);const diff=height-chart.plotHeight;if(!chart.scrollablePixelsY&&Math.abs(diff)>=1){chart.plotHeight=height;chart.redrawTrigger="adjustHeight";chart.setSize(void 0,chart.chartHeight+diff,animate)}axis.series.forEach(function(series){const clipRect=series.sharedClipKey&&chart.sharedClips[series.sharedClipKey];if(clipRect){clipRect.attr(chart.inverted?{width:chart.plotHeight}:{height:chart.plotHeight})}})}}this.initiatedScale=true}this.redrawTrigger=null}const StaticScale={compose:StaticScale_compose};const Extensions_StaticScale=StaticScale;"";const static_scale_src_G=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();Extensions_StaticScale.compose(static_scale_src_G.Axis,static_scale_src_G.Chart);const static_scale_src=null&&Highcharts;const{correctFloat:XRangeSeriesDefaults_correctFloat,isNumber:XRangeSeriesDefaults_isNumber,isObject}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const XRangeSeriesDefaults={colorByPoint:true,dataLabels:{formatter:function(){let amount=this.partialFill;if(isObject(amount)){amount=amount.amount}if(XRangeSeriesDefaults_isNumber(amount)&&amount>0){return XRangeSeriesDefaults_correctFloat(amount*100)+"%"}},inside:true,verticalAlign:"middle",style:{whiteSpace:"nowrap"}},tooltip:{headerFormat:'<span style="font-size: 0.8em">{ucfirst point.x} - {point.x2}</span><br/>',pointFormat:'<span style="color:{point.color}"></span> {series.name}: <b>{point.yCategory}</b><br/>'},borderRadius:3,pointRange:0};const XRange_XRangeSeriesDefaults=XRangeSeriesDefaults;"";const{column:{prototype:{pointClass:ColumnPoint}}}=highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default().seriesTypes;const{extend:XRangePoint_extend}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();class XRangePoint extends ColumnPoint{static getColorByCategory(series,point){const colors=series.options.colors||series.chart.options.colors,colorCount=colors?colors.length:series.chart.options.chart.colorCount,colorIndex=point.y%colorCount,color=colors&&colors[colorIndex];return{colorIndex:colorIndex,color:color}}resolveColor(){const series=this.series;if(series.options.colorByPoint&&!this.options.color){const colorByPoint=XRangePoint.getColorByCategory(series,this);if(!series.chart.styledMode){this.color=colorByPoint.color}if(!this.options.colorIndex){this.colorIndex=colorByPoint.colorIndex}}else{this.color=this.options.color||series.color}}constructor(series,options){super(series,options);if(!this.y){this.y=0}}applyOptions(options,x){super.applyOptions(options,x);this.x2=this.series.chart.time.parse(this.x2);this.isNull=!this.isValid?.();return this}setState(){super.setState.apply(this,arguments);this.series.drawPoint(this,this.series.getAnimationVerb())}isValid(){return typeof this.x==="number"&&typeof this.x2==="number"}}XRangePoint_extend(XRangePoint.prototype,{ttBelow:false,tooltipDateKeys:["x","x2"]});const XRange_XRangePoint=XRangePoint;"";const{composed:XRangeSeries_composed,noop}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{parse:XRangeSeries_color}=highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default();const{column:ColumnSeries}=highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default().seriesTypes;const{addEvent:XRangeSeries_addEvent,clamp:XRangeSeries_clamp,crisp:XRangeSeries_crisp,defined:XRangeSeries_defined,extend:XRangeSeries_extend,find:XRangeSeries_find,isNumber:XRangeSeries_isNumber,isObject:XRangeSeries_isObject,merge:XRangeSeries_merge,pick:XRangeSeries_pick,pushUnique:XRangeSeries_pushUnique,relativeLength:XRangeSeries_relativeLength}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function onAxisAfterGetSeriesExtremes(){let dataMax,modMax;if(this.isXAxis){dataMax=XRangeSeries_pick(this.dataMax,-Number.MAX_VALUE);for(const series of this.series){const column=series.dataTable.getColumn("x2",true)||series.dataTable.getColumn("end",true);if(column){for(const val of column){if(XRangeSeries_isNumber(val)&&val>dataMax){dataMax=val;modMax=true}}}}if(modMax){this.dataMax=dataMax}}}class XRangeSeries extends ColumnSeries{static compose(AxisClass){if(XRangeSeries_pushUnique(XRangeSeries_composed,"Series.XRange")){XRangeSeries_addEvent(AxisClass,"afterGetSeriesExtremes",onAxisAfterGetSeriesExtremes)}}init(){super.init.apply(this,arguments);this.options.stacking=void 0}getColumnMetrics(){const swapAxes=()=>{for(const series of this.chart.series){const xAxis=series.xAxis;series.xAxis=series.yAxis;series.yAxis=xAxis}};swapAxes();const metrics=super.getColumnMetrics();swapAxes();return metrics}cropData(table,min,max){const xData=table.getColumn("x")||[],x2Data=table.getColumn("x2");table.setColumn("x",x2Data,void 0,{silent:true});const croppedData=super.cropData(table,min,max);table.setColumn("x",xData.slice(croppedData.start,croppedData.end),void 0,{silent:true});return croppedData}findPointIndex(options){const{cropStart,points}=this;const{id}=options;let pointIndex;if(id){const point=XRangeSeries_find(points,point=>point.id===id);pointIndex=point?point.index:void 0}if(typeof pointIndex==="undefined"){const point=XRangeSeries_find(points,point=>point.x===options.x&&point.x2===options.x2&&!point.touched);pointIndex=point?point.index:void 0}if(this.cropped&&XRangeSeries_isNumber(pointIndex)&&XRangeSeries_isNumber(cropStart)&&pointIndex>=cropStart){pointIndex-=cropStart}return pointIndex}alignDataLabel(point){const oldPlotX=point.plotX;point.plotX=XRangeSeries_pick(point.dlBox&&point.dlBox.centerX,point.plotX);if(point.dataLabel&&point.shapeArgs?.width){point.dataLabel.css({width:`${point.shapeArgs.width}px`})}super.alignDataLabel.apply(this,arguments);point.plotX=oldPlotX}translatePoint(point){const xAxis=this.xAxis,yAxis=this.yAxis,metrics=this.columnMetrics,options=this.options,minPointLength=options.minPointLength||0,oldColWidth=(point.shapeArgs&&point.shapeArgs.width||0)/2,seriesXOffset=this.pointXOffset=metrics.offset,posX=XRangeSeries_pick(point.x2,point.x+(point.len||0)),borderRadius=options.borderRadius,plotTop=this.chart.plotTop,plotLeft=this.chart.plotLeft;let plotX=point.plotX,plotX2=xAxis.translate(posX,0,0,0,1);const length=Math.abs(plotX2-plotX),inverted=this.chart.inverted,borderWidth=XRangeSeries_pick(options.borderWidth,1);let widthDifference,partialFill,yOffset=metrics.offset,pointHeight=Math.round(metrics.width),dlLeft,dlRight,dlWidth,clipRectWidth;if(minPointLength){widthDifference=minPointLength-length;if(widthDifference<0){widthDifference=0}plotX-=widthDifference/2;plotX2+=widthDifference/2}plotX=Math.max(plotX,-10);plotX2=XRangeSeries_clamp(plotX2,-10,xAxis.len+10);if(XRangeSeries_defined(point.options.pointWidth)){yOffset-=(Math.ceil(point.options.pointWidth)-pointHeight)/2;pointHeight=Math.ceil(point.options.pointWidth)}if(options.pointPlacement&&XRangeSeries_isNumber(point.plotY)&&yAxis.categories){point.plotY=yAxis.translate(point.y,0,1,0,1,options.pointPlacement)}const x=XRangeSeries_crisp(Math.min(plotX,plotX2),borderWidth),x2=XRangeSeries_crisp(Math.max(plotX,plotX2),borderWidth),width=x2-x;const r=Math.min(XRangeSeries_relativeLength(typeof borderRadius==="object"?borderRadius.radius:borderRadius||0,pointHeight),Math.min(width,pointHeight)/2);const shapeArgs={x:x,y:XRangeSeries_crisp((point.plotY||0)+yOffset,borderWidth),width:width,height:pointHeight,r:r};point.shapeArgs=shapeArgs;if(!inverted){point.tooltipPos[0]-=oldColWidth+seriesXOffset-shapeArgs.width/2}else{point.tooltipPos[1]+=seriesXOffset+oldColWidth}dlLeft=shapeArgs.x;dlRight=dlLeft+shapeArgs.width;if(dlLeft<0||dlRight>xAxis.len){dlLeft=XRangeSeries_clamp(dlLeft,0,xAxis.len);dlRight=XRangeSeries_clamp(dlRight,0,xAxis.len);dlWidth=dlRight-dlLeft;point.dlBox=XRangeSeries_merge(shapeArgs,{x:dlLeft,width:dlRight-dlLeft,centerX:dlWidth?dlWidth/2:null})}else{point.dlBox=null}const tooltipPos=point.tooltipPos;const xIndex=!inverted?0:1;const yIndex=!inverted?1:0;const tooltipYOffset=this.columnMetrics?this.columnMetrics.offset:-metrics.width/2;if(inverted){tooltipPos[xIndex]+=shapeArgs.width/2}else{tooltipPos[xIndex]=XRangeSeries_clamp(tooltipPos[xIndex]+(xAxis.reversed?-1:0)*shapeArgs.width,xAxis.left-plotLeft,xAxis.left+xAxis.len-plotLeft-1)}tooltipPos[yIndex]=XRangeSeries_clamp(tooltipPos[yIndex]+(inverted?-1:1)*tooltipYOffset,yAxis.top-plotTop,yAxis.top+yAxis.len-plotTop-1);partialFill=point.partialFill;if(partialFill){if(XRangeSeries_isObject(partialFill)){partialFill=partialFill.amount}if(!XRangeSeries_isNumber(partialFill)){partialFill=0}point.partShapeArgs=XRangeSeries_merge(shapeArgs);clipRectWidth=Math.max(Math.round(length*partialFill+point.plotX-plotX),0);point.clipRectArgs={x:xAxis.reversed?shapeArgs.x+length-clipRectWidth:shapeArgs.x,y:shapeArgs.y,width:clipRectWidth,height:shapeArgs.height}}point.key=point.category||point.name;point.yCategory=yAxis.categories?.[point.y??-1]}translate(){super.translate.apply(this,arguments);for(const point of this.points){this.translatePoint(point)}}drawPoint(point,verb){const seriesOpts=this.options,renderer=this.chart.renderer,type=point.shapeType,shapeArgs=point.shapeArgs,partShapeArgs=point.partShapeArgs,clipRectArgs=point.clipRectArgs,pointState=point.state,stateOpts=seriesOpts.states[pointState||"normal"]||{},pointStateVerb=typeof pointState==="undefined"?"attr":verb,pointAttr=this.pointAttribs(point,pointState),animation=XRangeSeries_pick(this.chart.options.chart.animation,stateOpts.animation);let graphic=point.graphic,pfOptions=point.partialFill;if(!point.isNull&&point.visible!==false){if(graphic){graphic.rect[verb](shapeArgs)}else{point.graphic=graphic=renderer.g("point").addClass(point.getClassName()).add(point.group||this.group);graphic.rect=renderer[type](XRangeSeries_merge(shapeArgs)).addClass(point.getClassName()).addClass("highcharts-partfill-original").add(graphic)}if(partShapeArgs){if(graphic.partRect){graphic.partRect[verb](XRangeSeries_merge(partShapeArgs));graphic.partialClipRect[verb](XRangeSeries_merge(clipRectArgs))}else{graphic.partialClipRect=renderer.clipRect(clipRectArgs.x,clipRectArgs.y,clipRectArgs.width,clipRectArgs.height);graphic.partRect=renderer[type](partShapeArgs).addClass("highcharts-partfill-overlay").add(graphic).clip(graphic.partialClipRect)}}if(!this.chart.styledMode){graphic.rect[verb](pointAttr,animation).shadow(seriesOpts.shadow);if(partShapeArgs){if(!XRangeSeries_isObject(pfOptions)){pfOptions={}}if(XRangeSeries_isObject(seriesOpts.partialFill)){pfOptions=XRangeSeries_merge(seriesOpts.partialFill,pfOptions)}const fill=pfOptions.fill||XRangeSeries_color(pointAttr.fill).brighten(-.3).get()||XRangeSeries_color(point.color||this.color).brighten(-.3).get();pointAttr.fill=fill;graphic.partRect[pointStateVerb](pointAttr,animation).shadow(seriesOpts.shadow)}}}else if(graphic){point.graphic=graphic.destroy()}}drawPoints(){const verb=this.getAnimationVerb();for(const point of this.points){this.drawPoint(point,verb)}}getAnimationVerb(){return this.chart.pointCount<(this.options.animationLimit||250)?"animate":"attr"}isPointInside(point){const shapeArgs=point.shapeArgs,plotX=point.plotX,plotY=point.plotY;if(!shapeArgs){return super.isPointInside.apply(this,arguments)}const isInside=typeof plotX!=="undefined"&&typeof plotY!=="undefined"&&plotY>=0&&plotY<=this.yAxis.len&&(shapeArgs.x||0)+(shapeArgs.width||0)>=0&&plotX<=this.xAxis.len;return isInside}}XRangeSeries.defaultOptions=XRangeSeries_merge(ColumnSeries.defaultOptions,XRange_XRangeSeriesDefaults);XRangeSeries_extend(XRangeSeries.prototype,{pointClass:XRange_XRangePoint,pointArrayMap:["x2","y"],getExtremesFromAll:true,keysAffectYAxis:["y"],parallelArrays:["x","x2","y"],requireSorting:false,type:"xrange",animate:highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default().series.prototype.animate,autoIncrement:noop,buildKDTree:noop});highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default().registerSeriesType("xrange",XRangeSeries);const XRange_XRangeSeries=XRangeSeries;const xrange_src_G=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();XRange_XRangeSeries.compose(xrange_src_G.Axis);const xrange_src=null&&Highcharts;const{xrange:{prototype:{pointClass:GanttPoint_XRangePoint}}}=highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default().seriesTypes;class GanttPoint extends GanttPoint_XRangePoint{static setGanttPointAliases(options,chart){options.x=options.start=chart.time.parse(options.start??options.x);options.x2=options.end=chart.time.parse(options.end??options.x2);options.partialFill=options.completed=options.completed??options.partialFill}applyOptions(options,x){const ganttPoint=super.applyOptions(options,x);GanttPoint.setGanttPointAliases(ganttPoint,ganttPoint.series.chart);this.isNull=!this.isValid?.();return ganttPoint}isValid(){return(typeof this.start==="number"||typeof this.x==="number")&&(typeof this.end==="number"||typeof this.x2==="number"||this.milestone)}}const Gantt_GanttPoint=GanttPoint;const{isNumber:GanttSeriesDefaults_isNumber}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const GanttSeriesDefaults={grouping:false,dataLabels:{enabled:true},tooltip:{headerFormat:'<span style="font-size: 0.8em">{series.name}</span><br/>',pointFormat:null,pointFormatter:function(){const point=this,series=point.series,xAxis=series.xAxis,formats=series.tooltipOptions.dateTimeLabelFormats,startOfWeek=xAxis.options.startOfWeek,ttOptions=series.tooltipOptions,milestone=point.options.milestone;let format=ttOptions.xDateFormat,retVal="<b>"+(point.name||point.yCategory)+"</b>";if(ttOptions.pointFormat){return point.tooltipFormatter(ttOptions.pointFormat)}if(!format&&GanttSeriesDefaults_isNumber(point.start)){format=series.chart.time.getDateFormat(xAxis.closestPointRange,point.start,startOfWeek,formats||{})}const start=series.chart.time.dateFormat(format,point.start),end=series.chart.time.dateFormat(format,point.end);retVal+="<br/>";if(!milestone){retVal+="Start: "+start+"<br/>";retVal+="End: "+end+"<br/>"}else{retVal+=start+"<br/>"}return retVal}},connectors:{type:"simpleConnect",animation:{reversed:true},radius:0,startMarker:{enabled:true,symbol:"arrow-filled",radius:4,fill:"#fa0",align:"left"},endMarker:{enabled:false,align:"right"}}};"";const Gantt_GanttSeriesDefaults=GanttSeriesDefaults;var highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_=__webpack_require__(184);var highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_default=__webpack_require__.n(highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_);const{addEvent:BrokenAxis_addEvent,find:BrokenAxis_find,fireEvent:BrokenAxis_fireEvent,isArray:BrokenAxis_isArray,isNumber:BrokenAxis_isNumber,pick:BrokenAxis_pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();var BrokenAxis;(function(BrokenAxis){function compose(AxisClass,SeriesClass){if(!AxisClass.keepProps.includes("brokenAxis")){AxisClass.keepProps.push("brokenAxis");BrokenAxis_addEvent(AxisClass,"init",onAxisInit);BrokenAxis_addEvent(AxisClass,"afterInit",onAxisAfterInit);BrokenAxis_addEvent(AxisClass,"afterSetTickPositions",onAxisAfterSetTickPositions);BrokenAxis_addEvent(AxisClass,"afterSetOptions",onAxisAfterSetOptions);const seriesProto=SeriesClass.prototype;seriesProto.drawBreaks=seriesDrawBreaks;seriesProto.gappedPath=seriesGappedPath;BrokenAxis_addEvent(SeriesClass,"afterGeneratePoints",onSeriesAfterGeneratePoints);BrokenAxis_addEvent(SeriesClass,"afterRender",onSeriesAfterRender)}return AxisClass}BrokenAxis.compose=compose;function onAxisAfterInit(){if(typeof this.brokenAxis!=="undefined"){this.brokenAxis.setBreaks(this.options.breaks,false)}}function onAxisAfterSetOptions(){const axis=this;if(axis.brokenAxis?.hasBreaks){axis.options.ordinal=false}}function onAxisAfterSetTickPositions(){const axis=this,brokenAxis=axis.brokenAxis;if(brokenAxis?.hasBreaks){const tickPositions=axis.tickPositions,info=axis.tickPositions.info,newPositions=[];for(let i=0;i<tickPositions.length;i++){if(!brokenAxis.isInAnyBreak(tickPositions[i])){newPositions.push(tickPositions[i])}}axis.tickPositions=newPositions;axis.tickPositions.info=info}}function onAxisInit(){const axis=this;if(!axis.brokenAxis){axis.brokenAxis=new Additions(axis)}}function onSeriesAfterGeneratePoints(){const{isDirty,options:{connectNulls},points,xAxis,yAxis}=this;if(isDirty){let i=points.length;while(i--){const point=points[i];const nullGap=point.y===null&&connectNulls===false;const isPointInBreak=!nullGap&&(xAxis?.brokenAxis?.isInAnyBreak(point.x,true)||yAxis?.brokenAxis?.isInAnyBreak(point.y,true));point.visible=isPointInBreak?false:point.options.visible!==false}}}function onSeriesAfterRender(){this.drawBreaks(this.xAxis,["x"]);this.drawBreaks(this.yAxis,BrokenAxis_pick(this.pointArrayMap,["y"]))}function seriesDrawBreaks(axis,keys){const series=this,points=series.points;let breaks,threshold,y;if(axis?.brokenAxis?.hasBreaks){const brokenAxis=axis.brokenAxis;keys.forEach(function(key){breaks=brokenAxis?.breakArray||[];threshold=axis.isXAxis?axis.min:BrokenAxis_pick(series.options.threshold,axis.min);const breaksOutOfRange=axis?.options?.breaks?.filter(function(brk){let isOut=true;for(let i=0;i<breaks.length;i++){const otherBreak=breaks[i];if(otherBreak.from===brk.from&&otherBreak.to===brk.to){isOut=false;break}}return isOut});points.forEach(function(point){y=BrokenAxis_pick(point["stack"+key.toUpperCase()],point[key]);breaks.forEach(function(brk){if(BrokenAxis_isNumber(threshold)&&BrokenAxis_isNumber(y)){let eventName="";if(threshold<brk.from&&y>brk.to||threshold>brk.from&&y<brk.from){eventName="pointBreak"}else if(threshold<brk.from&&y>brk.from&&y<brk.to||threshold>brk.from&&y>brk.to&&y<brk.from){eventName="pointInBreak"}if(eventName){BrokenAxis_fireEvent(axis,eventName,{point:point,brk:brk})}}});breaksOutOfRange?.forEach(function(brk){BrokenAxis_fireEvent(axis,"pointOutsideOfBreak",{point:point,brk:brk})})})})}}function seriesGappedPath(){const currentDataGrouping=this.currentDataGrouping,groupingSize=currentDataGrouping?.gapSize,points=this.points.slice(),yAxis=this.yAxis;let gapSize=this.options.gapSize,i=points.length-1,stack;if(gapSize&&i>0){if(this.options.gapUnit!=="value"){gapSize*=this.basePointRange}if(groupingSize&&groupingSize>gapSize&&groupingSize>=this.basePointRange){gapSize=groupingSize}let current,next;while(i--){if(!(next&&next.visible!==false)){next=points[i+1]}current=points[i];if(next.visible===false||current.visible===false){continue}if(next.x-current.x>gapSize){const xRange=(current.x+next.x)/2;points.splice(i+1,0,{isNull:true,x:xRange});if(yAxis.stacking&&this.options.stacking){stack=yAxis.stacking.stacks[this.stackKey][xRange]=new(highcharts_StackItem_commonjs_highcharts_StackItem_commonjs2_highcharts_StackItem_root_Highcharts_StackItem_default())(yAxis,yAxis.options.stackLabels,false,xRange,this.stack);stack.total=0}}next=current}}return this.getGraphPath(points)}class Additions{static isInBreak(brk,val){const repeat=brk.repeat||Infinity,from=brk.from,length=brk.to-brk.from,test=val>=from?(val-from)%repeat:repeat-(from-val)%repeat;let ret;if(!brk.inclusive){ret=test<length&&test!==0}else{ret=test<=length}return ret}static lin2Val(val){const axis=this;const brokenAxis=axis.brokenAxis;const breakArray=brokenAxis&&brokenAxis.breakArray;if(!breakArray||!BrokenAxis_isNumber(val)){return val}let nval=val,brk,i;for(i=0;i<breakArray.length;i++){brk=breakArray[i];if(brk.from>=nval){break}else if(brk.to<nval){nval+=brk.len}else if(Additions.isInBreak(brk,nval)){nval+=brk.len}}return nval}static val2Lin(val){const axis=this;const brokenAxis=axis.brokenAxis;const breakArray=brokenAxis&&brokenAxis.breakArray;if(!breakArray||!BrokenAxis_isNumber(val)){return val}let nval=val,brk,i;for(i=0;i<breakArray.length;i++){brk=breakArray[i];if(brk.to<=val){nval-=brk.len}else if(brk.from>=val){break}else if(Additions.isInBreak(brk,val)){nval-=val-brk.from;break}}return nval}constructor(axis){this.hasBreaks=false;this.axis=axis}findBreakAt(x,breaks){return BrokenAxis_find(breaks,function(b){return b.from<x&&x<b.to})}isInAnyBreak(val,testKeep){const brokenAxis=this,axis=brokenAxis.axis,breaks=axis.options.breaks||[];let i=breaks.length,inbrk,keep,ret;if(i&&BrokenAxis_isNumber(val)){while(i--){if(Additions.isInBreak(breaks[i],val)){inbrk=true;if(!keep){keep=BrokenAxis_pick(breaks[i].showPoints,!axis.isXAxis)}}}if(inbrk&&testKeep){ret=inbrk&&!keep}else{ret=inbrk}}return ret}setBreaks(breaks,redraw){const brokenAxis=this,axis=brokenAxis.axis,time=axis.chart.time,hasBreaks=BrokenAxis_isArray(breaks)&&!!breaks.length&&!!Object.keys(breaks[0]).length;axis.isDirty=brokenAxis.hasBreaks!==hasBreaks;brokenAxis.hasBreaks=hasBreaks;breaks?.forEach(brk=>{brk.from=time.parse(brk.from)||0;brk.to=time.parse(brk.to)||0});if(breaks!==axis.options.breaks){axis.options.breaks=axis.userOptions.breaks=breaks}axis.forceRedraw=true;axis.series.forEach(function(series){series.isDirty=true});if(!hasBreaks&&axis.val2lin===Additions.val2Lin){delete axis.val2lin;delete axis.lin2val}if(hasBreaks){axis.userOptions.ordinal=false;axis.lin2val=Additions.lin2Val;axis.val2lin=Additions.val2Lin;axis.setExtremes=function(newMin,newMax,redraw,animation,eventArguments){if(brokenAxis.hasBreaks){const breaks=this.options.breaks||[];let axisBreak;while(axisBreak=brokenAxis.findBreakAt(newMin,breaks)){newMin=axisBreak.to}while(axisBreak=brokenAxis.findBreakAt(newMax,breaks)){newMax=axisBreak.from}if(newMax<newMin){newMax=newMin}}axis.constructor.prototype.setExtremes.call(this,newMin,newMax,redraw,animation,eventArguments)};axis.setAxisTranslation=function(){axis.constructor.prototype.setAxisTranslation.call(this);brokenAxis.unitLength=void 0;if(brokenAxis.hasBreaks){const breaks=axis.options.breaks||[],breakArrayT=[],breakArray=[],pointRangePadding=BrokenAxis_pick(axis.pointRangePadding,0);let length=0,inBrk,repeat,min=axis.userMin||axis.min,max=axis.userMax||axis.max,start,i;breaks.forEach(function(brk){repeat=brk.repeat||Infinity;if(BrokenAxis_isNumber(min)&&BrokenAxis_isNumber(max)){if(Additions.isInBreak(brk,min)){min+=brk.to%repeat-min%repeat}if(Additions.isInBreak(brk,max)){max-=max%repeat-brk.from%repeat}}});breaks.forEach(function(brk){start=brk.from;repeat=brk.repeat||Infinity;if(BrokenAxis_isNumber(min)&&BrokenAxis_isNumber(max)){while(start-repeat>min){start-=repeat}while(start<min){start+=repeat}for(i=start;i<max;i+=repeat){breakArrayT.push({value:i,move:"in"});breakArrayT.push({value:i+brk.to-brk.from,move:"out",size:brk.breakSize})}}});breakArrayT.sort(function(a,b){return a.value===b.value?(a.move==="in"?0:1)-(b.move==="in"?0:1):a.value-b.value});inBrk=0;start=min;breakArrayT.forEach(function(brk){inBrk+=brk.move==="in"?1:-1;if(inBrk===1&&brk.move==="in"){start=brk.value}if(inBrk===0&&BrokenAxis_isNumber(start)){breakArray.push({from:start,to:brk.value,len:brk.value-start-(brk.size||0)});length+=brk.value-start-(brk.size||0)}});brokenAxis.breakArray=breakArray;if(BrokenAxis_isNumber(min)&&BrokenAxis_isNumber(max)&&BrokenAxis_isNumber(axis.min)){brokenAxis.unitLength=max-min-length+pointRangePadding;BrokenAxis_fireEvent(axis,"afterBreaks");if(axis.staticScale){axis.transA=axis.staticScale}else if(brokenAxis.unitLength){axis.transA*=(max-axis.min+pointRangePadding)/brokenAxis.unitLength}if(pointRangePadding){axis.minPixelPadding=axis.transA*(axis.minPointOffset||0)}axis.min=min;axis.max=max}}}}if(BrokenAxis_pick(redraw,true)){axis.chart.redraw()}}}BrokenAxis.Additions=Additions})(BrokenAxis||(BrokenAxis={}));const Axis_BrokenAxis=BrokenAxis;const{dateFormats}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();const{addEvent:GridAxis_addEvent,defined:GridAxis_defined,erase:GridAxis_erase,find:GridAxis_find,isArray:GridAxis_isArray,isNumber:GridAxis_isNumber,merge:GridAxis_merge,pick:GridAxis_pick,timeUnits:GridAxis_timeUnits,wrap:GridAxis_wrap}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();var GridAxisSide;(function(GridAxisSide){GridAxisSide[GridAxisSide["top"]=0]="top";GridAxisSide[GridAxisSide["right"]=1]="right";GridAxisSide[GridAxisSide["bottom"]=2]="bottom";GridAxisSide[GridAxisSide["left"]=3]="left"})(GridAxisSide||(GridAxisSide={}));function argsToArray(args){return Array.prototype.slice.call(args,1)}function GridAxis_isObject(x){return highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().isObject(x,true)}function applyGridOptions(axis){const options=axis.options;options.labels.align=GridAxis_pick(options.labels.align,"center");if(!axis.categories){options.showLastLabel=false}axis.labelRotation=0;options.labels.rotation=0;options.minTickInterval=1}function GridAxis_compose(AxisClass,ChartClass,TickClass){if(!AxisClass.keepProps.includes("grid")){AxisClass.keepProps.push("grid");AxisClass.prototype.getMaxLabelDimensions=getMaxLabelDimensions;GridAxis_wrap(AxisClass.prototype,"unsquish",wrapUnsquish);GridAxis_wrap(AxisClass.prototype,"getOffset",wrapGetOffset);GridAxis_addEvent(AxisClass,"init",onInit);GridAxis_addEvent(AxisClass,"afterGetTitlePosition",onAfterGetTitlePosition);GridAxis_addEvent(AxisClass,"afterInit",onAfterInit);GridAxis_addEvent(AxisClass,"afterRender",onAfterRender);GridAxis_addEvent(AxisClass,"afterSetAxisTranslation",onAfterSetAxisTranslation);GridAxis_addEvent(AxisClass,"afterSetOptions",onAfterSetOptions);GridAxis_addEvent(AxisClass,"afterSetOptions",onAfterSetOptions2);GridAxis_addEvent(AxisClass,"afterSetScale",onAfterSetScale);GridAxis_addEvent(AxisClass,"afterTickSize",onAfterTickSize);GridAxis_addEvent(AxisClass,"trimTicks",onTrimTicks);GridAxis_addEvent(AxisClass,"destroy",onDestroy);GridAxis_addEvent(ChartClass,"afterSetChartSize",GridAxis_onChartAfterSetChartSize);GridAxis_addEvent(TickClass,"afterGetLabelPosition",onTickAfterGetLabelPosition);GridAxis_addEvent(TickClass,"labelFormat",onTickLabelFormat)}return AxisClass}function getMaxLabelDimensions(ticks,tickPositions){const dimensions={width:0,height:0};tickPositions.forEach(function(pos){const tick=ticks[pos];let labelHeight=0,labelWidth=0,label;if(GridAxis_isObject(tick)){label=GridAxis_isObject(tick.label)?tick.label:{};labelHeight=label.getBBox?label.getBBox().height:0;if(label.textStr&&!GridAxis_isNumber(label.textPxLength)){label.textPxLength=label.getBBox().width}labelWidth=GridAxis_isNumber(label.textPxLength)?Math.round(label.textPxLength):0;if(label.textStr){labelWidth=Math.round(label.getBBox().width)}dimensions.height=Math.max(labelHeight,dimensions.height);dimensions.width=Math.max(labelWidth,dimensions.width)}});if(this.type==="treegrid"&&this.treeGrid&&this.treeGrid.mapOfPosToGridNode){const treeDepth=this.treeGrid.mapOfPosToGridNode[-1].height||0;dimensions.width+=this.options.labels.indentation*(treeDepth-1)}return dimensions}function wrapGetOffset(proceed){const{grid}=this,columnsFirst=this.side===3;if(!columnsFirst){proceed.apply(this)}if(!grid?.isColumn){let columns=grid?.columns||[];if(columnsFirst){columns=columns.slice().reverse()}columns.forEach(column=>{column.getOffset()})}if(columnsFirst){proceed.apply(this)}}function onAfterGetTitlePosition(e){const axis=this;const options=axis.options;const gridOptions=options.grid||{};if(gridOptions.enabled===true){const{axisTitle,height:axisHeight,horiz,left:axisLeft,offset,opposite,options,top:axisTop,width:axisWidth}=axis;const tickSize=axis.tickSize();const titleWidth=axisTitle&&axisTitle.getBBox().width;const xOption=options.title.x;const yOption=options.title.y;const titleMargin=GridAxis_pick(options.title.margin,horiz?5:10);const titleFontSize=axisTitle?axis.chart.renderer.fontMetrics(axisTitle).f:0;const crispCorr=tickSize?tickSize[0]/2:0;const offAxis=(horiz?axisTop+axisHeight:axisLeft)+(horiz?1:-1)*(opposite?-1:1)*crispCorr+(axis.side===GridAxisSide.bottom?titleFontSize:0);e.titlePosition.x=horiz?axisLeft-(titleWidth||0)/2-titleMargin+xOption:offAxis+(opposite?axisWidth:0)+offset+xOption;e.titlePosition.y=horiz?offAxis-(opposite?axisHeight:0)+(opposite?titleFontSize:-titleFontSize)/2+offset+yOption:axisTop-titleMargin+yOption}}function onAfterInit(){const axis=this;const{chart,options:{grid:gridOptions={}},userOptions}=axis;if(gridOptions.enabled){applyGridOptions(axis)}if(gridOptions.columns){const columns=axis.grid.columns=[];let columnIndex=axis.grid.columnIndex=0;while(++columnIndex<gridOptions.columns.length){const columnOptions=GridAxis_merge(userOptions,gridOptions.columns[columnIndex],{isInternal:true,linkedTo:0,scrollbar:{enabled:false}},{grid:{columns:void 0}});const column=new(highcharts_Axis_commonjs_highcharts_Axis_commonjs2_highcharts_Axis_root_Highcharts_Axis_default())(axis.chart,columnOptions,"yAxis");column.grid.isColumn=true;column.grid.columnIndex=columnIndex;GridAxis_erase(chart.axes,column);GridAxis_erase(chart[axis.coll]||[],column);columns.push(column)}}}function onAfterRender(){const axis=this,{axisTitle,grid,options}=axis,gridOptions=options.grid||{};if(gridOptions.enabled===true){const min=axis.min||0,max=axis.max||0,firstTick=axis.ticks[axis.tickPositions[0]];if(axisTitle&&!axis.chart.styledMode&&firstTick?.slotWidth&&!axis.options.title.style.width){axisTitle.css({width:`${firstTick.slotWidth}px`})}axis.maxLabelDimensions=axis.getMaxLabelDimensions(axis.ticks,axis.tickPositions);if(axis.rightWall){axis.rightWall.destroy()}if(axis.grid&&axis.grid.isOuterAxis()&&axis.axisLine){const lineWidth=options.lineWidth;if(lineWidth){const linePath=axis.getLinePath(lineWidth),startPoint=linePath[0],endPoint=linePath[1],tickLength=(axis.tickSize("tick")||[1])[0],distance=tickLength*(axis.side===GridAxisSide.top||axis.side===GridAxisSide.left?-1:1);if(startPoint[0]==="M"&&endPoint[0]==="L"){if(axis.horiz){startPoint[2]+=distance;endPoint[2]+=distance}else{startPoint[1]+=distance;endPoint[1]+=distance}}if(!axis.horiz&&axis.chart.marginRight){const upperBorderStartPoint=startPoint,upperBorderEndPoint=["L",axis.left,startPoint[2]||0],upperBorderPath=[upperBorderStartPoint,upperBorderEndPoint],lowerBorderEndPoint=["L",axis.chart.chartWidth-axis.chart.marginRight,axis.toPixels(max+axis.tickmarkOffset)],lowerBorderStartPoint=["M",endPoint[1]||0,axis.toPixels(max+axis.tickmarkOffset)],lowerBorderPath=[lowerBorderStartPoint,lowerBorderEndPoint];if(!axis.grid.upperBorder&&min%1!==0){axis.grid.upperBorder=axis.grid.renderBorder(upperBorderPath)}if(axis.grid.upperBorder){axis.grid.upperBorder.attr({stroke:options.lineColor,"stroke-width":options.lineWidth});axis.grid.upperBorder.animate({d:upperBorderPath})}if(!axis.grid.lowerBorder&&max%1!==0){axis.grid.lowerBorder=axis.grid.renderBorder(lowerBorderPath)}if(axis.grid.lowerBorder){axis.grid.lowerBorder.attr({stroke:options.lineColor,"stroke-width":options.lineWidth});axis.grid.lowerBorder.animate({d:lowerBorderPath})}}if(!axis.grid.axisLineExtra){axis.grid.axisLineExtra=axis.grid.renderBorder(linePath)}else{axis.grid.axisLineExtra.attr({stroke:options.lineColor,"stroke-width":options.lineWidth});axis.grid.axisLineExtra.animate({d:linePath})}axis.axisLine[axis.showAxis?"show":"hide"]()}}(grid&&grid.columns||[]).forEach(column=>column.render());if(!axis.horiz&&axis.chart.hasRendered&&(axis.scrollbar||axis.linkedParent&&axis.linkedParent.scrollbar)&&axis.tickPositions.length){const tickmarkOffset=axis.tickmarkOffset,lastTick=axis.tickPositions[axis.tickPositions.length-1],firstTick=axis.tickPositions[0];let label,tickMark;while((label=axis.hiddenLabels.pop())&&label.element){label.show()}while((tickMark=axis.hiddenMarks.pop())&&tickMark.element){tickMark.show()}label=axis.ticks[firstTick].label;if(label){if(min-firstTick>tickmarkOffset){axis.hiddenLabels.push(label.hide())}else{label.show()}}label=axis.ticks[lastTick].label;if(label){if(lastTick-max>tickmarkOffset){axis.hiddenLabels.push(label.hide())}else{label.show()}}const mark=axis.ticks[lastTick].mark;if(mark&&lastTick-max<tickmarkOffset&&lastTick-max>0&&axis.ticks[lastTick].isLast){axis.hiddenMarks.push(mark.hide())}}}}function onAfterSetAxisTranslation(){const axis=this;const tickInfo=axis.tickPositions&&axis.tickPositions.info;const options=axis.options;const gridOptions=options.grid||{};const userLabels=axis.userOptions.labels||{};if(gridOptions.enabled){if(axis.horiz){axis.series.forEach(series=>{series.options.pointRange=0});if(tickInfo&&options.dateTimeLabelFormats&&options.labels&&!GridAxis_defined(userLabels.align)&&(options.dateTimeLabelFormats[tickInfo.unitName].range===false||tickInfo.count>1)){options.labels.align="left";if(!GridAxis_defined(userLabels.x)){options.labels.x=3}}}else{if(this.type!=="treegrid"&&axis.grid&&axis.grid.columns){this.minPointOffset=this.tickInterval}}}}function onAfterSetOptions(e){const options=this.options,userOptions=e.userOptions,gridOptions=options&&GridAxis_isObject(options.grid)?options.grid:{};let gridAxisOptions;if(gridOptions.enabled===true){gridAxisOptions=GridAxis_merge(true,{className:"highcharts-grid-axis "+(userOptions.className||""),dateTimeLabelFormats:{hour:{list:["%[HM]","%[H]"]},day:{list:["%[AeB]","%[aeb]","%[E]"]},week:{list:["Week %W","W%W"]},month:{list:["%[B]","%[b]","%o"]}},grid:{borderWidth:1},labels:{padding:2,style:{fontSize:"0.9em"}},margin:0,title:{text:null,reserveSpace:false,rotation:0,style:{textOverflow:"ellipsis"}},units:[["millisecond",[1,10,100]],["second",[1,10]],["minute",[1,5,15]],["hour",[1,6]],["day",[1]],["week",[1]],["month",[1]],["year",null]]},userOptions);if(this.coll==="xAxis"){if(GridAxis_defined(userOptions.linkedTo)&&!GridAxis_defined(userOptions.tickPixelInterval)){gridAxisOptions.tickPixelInterval=350}if(!GridAxis_defined(userOptions.tickPixelInterval)&&GridAxis_defined(userOptions.linkedTo)&&!GridAxis_defined(userOptions.tickPositioner)&&!GridAxis_defined(userOptions.tickInterval)&&!GridAxis_defined(userOptions.units)){gridAxisOptions.tickPositioner=function(min,max){const parentInfo=this.linkedParent&&this.linkedParent.tickPositions&&this.linkedParent.tickPositions.info;if(parentInfo){const units=gridAxisOptions.units||[];let unitIdx,count=1,unitName="year";for(let i=0;i<units.length;i++){const unit=units[i];if(unit&&unit[0]===parentInfo.unitName){unitIdx=i;break}}const unit=GridAxis_isNumber(unitIdx)&&units[unitIdx+1];if(unit){unitName=unit[0]||"year";const counts=unit[1];count=counts&&counts[0]||1}else if(parentInfo.unitName==="year"){count=parentInfo.count*10}const unitRange=GridAxis_timeUnits[unitName];this.tickInterval=unitRange*count;return this.chart.time.getTimeTicks({unitRange:unitRange,count:count,unitName:unitName},min,max,this.options.startOfWeek)}}}}GridAxis_merge(true,this.options,gridAxisOptions);if(this.horiz){options.minPadding=GridAxis_pick(userOptions.minPadding,0);options.maxPadding=GridAxis_pick(userOptions.maxPadding,0)}if(GridAxis_isNumber(options.grid.borderWidth)){options.tickWidth=options.lineWidth=gridOptions.borderWidth}}}function onAfterSetOptions2(e){const axis=this;const userOptions=e.userOptions;const gridOptions=userOptions&&userOptions.grid||{};const columns=gridOptions.columns;if(gridOptions.enabled&&columns){GridAxis_merge(true,axis.options,columns[0])}}function onAfterSetScale(){const axis=this;(axis.grid.columns||[]).forEach(column=>column.setScale())}function onAfterTickSize(e){const{horiz,maxLabelDimensions,options:{grid:gridOptions={}}}=this;if(gridOptions.enabled&&maxLabelDimensions){const labelPadding=this.options.labels.distance*2;const distance=horiz?gridOptions.cellHeight||labelPadding+maxLabelDimensions.height:labelPadding+maxLabelDimensions.width;if(GridAxis_isArray(e.tickSize)){e.tickSize[0]=distance}else{e.tickSize=[distance,0]}}}function GridAxis_onChartAfterSetChartSize(){this.axes.forEach(axis=>{(axis.grid&&axis.grid.columns||[]).forEach(column=>{column.setAxisSize();column.setAxisTranslation()})})}function onDestroy(e){const{grid}=this;(grid.columns||[]).forEach(column=>column.destroy(e.keepEvents));grid.columns=void 0}function onInit(e){const axis=this;const userOptions=e.userOptions||{};const gridOptions=userOptions.grid||{};if(gridOptions.enabled&&GridAxis_defined(gridOptions.borderColor)){userOptions.tickColor=userOptions.lineColor=gridOptions.borderColor}if(!axis.grid){axis.grid=new GridAxisAdditions(axis)}axis.hiddenLabels=[];axis.hiddenMarks=[]}function onTickAfterGetLabelPosition(e){const tick=this,label=tick.label,axis=tick.axis,reversed=axis.reversed,chart=axis.chart,options=axis.options,gridOptions=options.grid||{},labelOpts=axis.options.labels,align=labelOpts.align,verticalAlign="middle",side=GridAxisSide[axis.side],tickmarkOffset=e.tickmarkOffset,tickPositions=axis.tickPositions,tickPos=tick.pos-tickmarkOffset,nextTickPos=GridAxis_isNumber(tickPositions[e.index+1])?tickPositions[e.index+1]-tickmarkOffset:(axis.max||0)+tickmarkOffset,tickSize=axis.tickSize("tick"),tickWidth=tickSize?tickSize[0]:0,crispCorr=tickSize?tickSize[1]/2:0;if(gridOptions.enabled===true){let bottom,top,left,right;if(side==="top"){bottom=axis.top+axis.offset;top=bottom-tickWidth}else if(side==="bottom"){top=chart.chartHeight-axis.bottom+axis.offset;bottom=top+tickWidth}else{bottom=axis.top+axis.len-(axis.translate(reversed?nextTickPos:tickPos)||0);top=axis.top+axis.len-(axis.translate(reversed?tickPos:nextTickPos)||0)}if(side==="right"){left=chart.chartWidth-axis.right+axis.offset;right=left+tickWidth}else if(side==="left"){right=axis.left+axis.offset;left=right-tickWidth}else{left=Math.round(axis.left+(axis.translate(reversed?nextTickPos:tickPos)||0))-crispCorr;right=Math.min(Math.round(axis.left+(axis.translate(reversed?tickPos:nextTickPos)||0))-crispCorr,axis.left+axis.len)}tick.slotWidth=right-left;e.pos.x=align==="left"?left:align==="right"?right:left+(right-left)/2;e.pos.y=verticalAlign==="top"?top:verticalAlign==="bottom"?bottom:top+(bottom-top)/2;if(label){const lblMetrics=chart.renderer.fontMetrics(label),labelHeight=label.getBBox().height;if(!labelOpts.useHTML){const lines=Math.round(labelHeight/lblMetrics.h);e.pos.y+=(lblMetrics.b-(lblMetrics.h-lblMetrics.f))/2+-((lines-1)*lblMetrics.h/2)}else{e.pos.y+=lblMetrics.b+-(labelHeight/2)}}e.pos.x+=axis.horiz&&labelOpts.x||0}}function onTickLabelFormat(ctx){const{axis,value}=ctx;if(axis.options.grid&&axis.options.grid.enabled){const tickPos=axis.tickPositions;const series=(axis.linkedParent||axis).series[0];const isFirst=value===tickPos[0];const isLast=value===tickPos[tickPos.length-1];const point=series&&GridAxis_find(series.options.data,function(p){return p[axis.isXAxis?"x":"y"]===value});let pointCopy;if(point&&series.is("gantt")){pointCopy=GridAxis_merge(point);highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default().seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(pointCopy,axis.chart)}ctx.isFirst=isFirst;ctx.isLast=isLast;ctx.point=pointCopy}}function onTrimTicks(){const axis=this,options=axis.options,gridOptions=options.grid||{},categoryAxis=axis.categories,tickPositions=axis.tickPositions,firstPos=tickPositions[0],secondPos=tickPositions[1],lastPos=tickPositions[tickPositions.length-1],beforeLastPos=tickPositions[tickPositions.length-2],linkedMin=axis.linkedParent&&axis.linkedParent.min,linkedMax=axis.linkedParent&&axis.linkedParent.max,min=linkedMin||axis.min,max=linkedMax||axis.max,tickInterval=axis.tickInterval,startLessThanMin=GridAxis_isNumber(min)&&min>=firstPos+tickInterval&&min<secondPos,endMoreThanMin=GridAxis_isNumber(min)&&firstPos<min&&firstPos+tickInterval>min,startLessThanMax=GridAxis_isNumber(max)&&lastPos>max&&lastPos-tickInterval<max,endMoreThanMax=GridAxis_isNumber(max)&&max<=lastPos-tickInterval&&max>beforeLastPos;if(gridOptions.enabled===true&&!categoryAxis&&(axis.isXAxis||axis.isLinked)){if((endMoreThanMin||startLessThanMin)&&!options.startOnTick){tickPositions[0]=min}if((startLessThanMax||endMoreThanMax)&&!options.endOnTick){tickPositions[tickPositions.length-1]=max}}}function wrapUnsquish(proceed){const axis=this;const{options:{grid:gridOptions={}}}=axis;if(gridOptions.enabled===true&&axis.categories){return axis.tickInterval}return proceed.apply(axis,argsToArray(arguments))}class GridAxisAdditions{constructor(axis){this.axis=axis}isOuterAxis(){const axis=this.axis;const chart=axis.chart;const columnIndex=axis.grid.columnIndex;const columns=axis.linkedParent?.grid.columns||axis.grid.columns||[];const parentAxis=columnIndex?axis.linkedParent:axis;let thisIndex=-1,lastIndex=0;if(axis.side===3&&!chart.inverted&&columns.length){return!axis.linkedParent}(chart[axis.coll]||[]).forEach((otherAxis,index)=>{if(otherAxis.side===axis.side&&!otherAxis.options.isInternal){lastIndex=index;if(otherAxis===parentAxis){thisIndex=index}}});return lastIndex===thisIndex&&(GridAxis_isNumber(columnIndex)?columns.length===columnIndex:true)}renderBorder(path){const axis=this.axis,renderer=axis.chart.renderer,options=axis.options,extraBorderLine=renderer.path(path).addClass("highcharts-axis-line").add(axis.axisGroup);if(!renderer.styledMode){extraBorderLine.attr({stroke:options.lineColor,"stroke-width":options.lineWidth,zIndex:7})}return extraBorderLine}}dateFormats.E=function(timestamp){return this.dateFormat("%a",timestamp,true).charAt(0)};dateFormats.W=function(timestamp){const d=this.toParts(timestamp),firstDay=(d[7]+6)%7,thursday=d.slice(0);thursday[2]=d[2]-firstDay+3;const firstThursday=this.toParts(this.makeTime(thursday[0],0,1));if(firstThursday[7]!==4){d[1]=0;d[2]=1+(11-firstThursday[7])%7}const thursdayTS=this.makeTime(thursday[0],thursday[1],thursday[2]),firstThursdayTS=this.makeTime(firstThursday[0],firstThursday[1],firstThursday[2]);return(1+Math.floor((thursdayTS-firstThursdayTS)/6048e5)).toString()};const GridAxis={compose:GridAxis_compose};const Axis_GridAxis=GridAxis;"";const{extend:Tree_extend,isNumber:Tree_isNumber,pick:Tree_pick}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function getListOfParents(data){const root="",ids=[],listOfParents=data.reduce((prev,curr)=>{const{parent="",id}=curr;if(typeof prev[parent]==="undefined"){prev[parent]=[]}prev[parent].push(curr);if(id){ids.push(id)}return prev},{});Object.keys(listOfParents).forEach(node=>{if(node!==root&&ids.indexOf(node)===-1){const adoptedByRoot=listOfParents[node].map(function(orphan){const{...parentExcluded}=orphan;return parentExcluded});listOfParents[root].push(...adoptedByRoot);delete listOfParents[node]}});return listOfParents}function getNode(id,parent,level,data,mapOfIdToChildren,options){const after=options&&options.after,before=options&&options.before,node={data:data,depth:level-1,id:id,level:level,parent:parent||""};let descendants=0,height=0,start,end;if(typeof before==="function"){before(node,options)}const children=(mapOfIdToChildren[id]||[]).map(child=>{const node=getNode(child.id,id,level+1,child,mapOfIdToChildren,options),childStart=child.start||NaN,childEnd=child.milestone===true?childStart:child.end||NaN;start=!Tree_isNumber(start)||childStart<start?childStart:start;end=!Tree_isNumber(end)||childEnd>end?childEnd:end;descendants=descendants+1+node.descendants;height=Math.max(node.height+1,height);return node});if(data){data.start=Tree_pick(data.start,start);data.end=Tree_pick(data.end,end)}Tree_extend(node,{children:children,descendants:descendants,height:height});if(typeof after==="function"){after(node,options)}return node}function getTree(data,options){return getNode("",null,1,null,getListOfParents(data),options)}const Tree={getNode:getNode,getTree:getTree};const Gantt_Tree=Tree;const{addEvent:TreeGridTick_addEvent,removeEvent:TreeGridTick_removeEvent,isObject:TreeGridTick_isObject,isNumber:TreeGridTick_isNumber,pick:TreeGridTick_pick,wrap:TreeGridTick_wrap}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function onTickInit(){const tick=this;if(!tick.treeGrid){tick.treeGrid=new TreeGridTickAdditions(tick)}}function onTickHover(label){label.addClass("highcharts-treegrid-node-active");if(!label.renderer.styledMode){label.css({textDecoration:"underline"})}}function onTickHoverExit(label,options){const css=TreeGridTick_isObject(options.style)?options.style:{};label.removeClass("highcharts-treegrid-node-active");if(!label.renderer.styledMode){label.css({textDecoration:css.textDecoration||"none"})}}function renderLabelIcon(tick,params){const treeGrid=tick.treeGrid,isNew=!treeGrid.labelIcon,renderer=params.renderer,labelBox=params.xy,options=params.options,width=options.width||0,height=options.height||0,padding=options.padding??tick.axis.linkedParent?0:5,iconCenter={x:labelBox.x-width/2-padding,y:labelBox.y-height/2},rotation=params.collapsed?90:180,shouldRender=params.show&&TreeGridTick_isNumber(iconCenter.y);let icon=treeGrid.labelIcon;if(!icon){treeGrid.labelIcon=icon=renderer.path(renderer.symbols[options.type](options.x||0,options.y||0,width,height)).addClass("highcharts-label-icon").add(params.group)}icon[shouldRender?"show":"hide"]();if(!renderer.styledMode){icon.attr({cursor:"pointer",fill:TreeGridTick_pick(params.color,"#666666"),"stroke-width":1,stroke:options.lineColor,strokeWidth:options.lineWidth||0})}icon[isNew?"attr":"animate"]({translateX:iconCenter.x,translateY:iconCenter.y,rotation:rotation})}function wrapGetLabelPosition(proceed,x,y,label,horiz,labelOptions,tickmarkOffset,index,step){const tick=this,lbOptions=TreeGridTick_pick(tick.options&&tick.options.labels,labelOptions),pos=tick.pos,axis=tick.axis,isTreeGrid=axis.type==="treegrid",result=proceed.apply(tick,[x,y,label,horiz,lbOptions,tickmarkOffset,index,step]);let mapOfPosToGridNode,node,level;if(isTreeGrid){const{width=0,padding=axis.linkedParent?0:5}=lbOptions&&TreeGridTick_isObject(lbOptions.symbol,true)?lbOptions.symbol:{},indentation=lbOptions&&TreeGridTick_isNumber(lbOptions.indentation)?lbOptions.indentation:0;mapOfPosToGridNode=axis.treeGrid.mapOfPosToGridNode;node=mapOfPosToGridNode&&mapOfPosToGridNode[pos];level=node&&node.depth||1;result.x+=width+padding*2+(level-1)*indentation}return result}function wrapRenderLabel(proceed){const tick=this,{pos,axis,label,treeGrid:tickGrid,options:tickOptions}=tick,icon=tickGrid?.labelIcon,labelElement=label?.element,{treeGrid:axisGrid,options:axisOptions,chart,tickPositions}=axis,mapOfPosToGridNode=axisGrid.mapOfPosToGridNode,labelOptions=TreeGridTick_pick(tickOptions?.labels,axisOptions?.labels),symbolOptions=labelOptions&&TreeGridTick_isObject(labelOptions.symbol,true)?labelOptions.symbol:{},node=mapOfPosToGridNode&&mapOfPosToGridNode[pos],{descendants,depth}=node||{},hasDescendants=node&&descendants&&descendants>0,level=depth,isTreeGridElement=axis.type==="treegrid"&&labelElement,shouldRender=tickPositions.indexOf(pos)>-1,prefixClassName="highcharts-treegrid-node-",prefixLevelClass=prefixClassName+"level-",styledMode=chart.styledMode;let collapsed,addClassName,removeClassName;if(isTreeGridElement&&node){label.removeClass(new RegExp(prefixLevelClass+".*")).addClass(prefixLevelClass+level)}proceed.apply(tick,Array.prototype.slice.call(arguments,1));if(isTreeGridElement&&hasDescendants){collapsed=axisGrid.isCollapsed(node);renderLabelIcon(tick,{color:!styledMode&&label.styles.color||"",collapsed:collapsed,group:label.parentGroup,options:symbolOptions,renderer:label.renderer,show:shouldRender,xy:label.xy});addClassName=prefixClassName+(collapsed?"collapsed":"expanded");removeClassName=prefixClassName+(collapsed?"expanded":"collapsed");label.addClass(addClassName).removeClass(removeClassName);if(!styledMode){label.css({cursor:"pointer"})}[label,icon].forEach(object=>{if(object&&!object.attachedTreeGridEvents){TreeGridTick_addEvent(object.element,"mouseover",function(){onTickHover(label)});TreeGridTick_addEvent(object.element,"mouseout",function(){onTickHoverExit(label,labelOptions)});TreeGridTick_addEvent(object.element,"click",function(){tickGrid.toggleCollapse()});object.attachedTreeGridEvents=true}})}else if(icon){TreeGridTick_removeEvent(labelElement);label?.css({cursor:"default"});icon.destroy()}}class TreeGridTickAdditions{static compose(TickClass){const tickProto=TickClass.prototype;if(!tickProto.toggleCollapse){TreeGridTick_addEvent(TickClass,"init",onTickInit);TreeGridTick_wrap(tickProto,"getLabelPosition",wrapGetLabelPosition);TreeGridTick_wrap(tickProto,"renderLabel",wrapRenderLabel);tickProto.collapse=function(redraw){this.treeGrid.collapse(redraw)};tickProto.expand=function(redraw){this.treeGrid.expand(redraw)};tickProto.toggleCollapse=function(redraw){this.treeGrid.toggleCollapse(redraw)}}}constructor(tick){this.tick=tick}collapse(redraw){const tick=this.tick,axis=tick.axis,brokenAxis=axis.brokenAxis;if(brokenAxis&&axis.treeGrid.mapOfPosToGridNode){const pos=tick.pos,node=axis.treeGrid.mapOfPosToGridNode[pos],breaks=axis.treeGrid.collapse(node);brokenAxis.setBreaks(breaks,TreeGridTick_pick(redraw,true))}}destroy(){if(this.labelIcon){this.labelIcon.destroy()}}expand(redraw){const{pos,axis}=this.tick,{treeGrid,brokenAxis}=axis,posMappedNodes=treeGrid.mapOfPosToGridNode;if(brokenAxis&&posMappedNodes){const node=posMappedNodes[pos],breaks=treeGrid.expand(node);brokenAxis.setBreaks(breaks,TreeGridTick_pick(redraw,true))}}toggleCollapse(redraw){const tick=this.tick,axis=tick.axis,brokenAxis=axis.brokenAxis;if(brokenAxis&&axis.treeGrid.mapOfPosToGridNode){const pos=tick.pos,node=axis.treeGrid.mapOfPosToGridNode[pos],breaks=axis.treeGrid.toggleCollapse(node);brokenAxis.setBreaks(breaks,TreeGridTick_pick(redraw,true))}}}const TreeGridTick=TreeGridTickAdditions;const{extend:TreeUtilities_extend,isArray:TreeUtilities_isArray,isNumber:TreeUtilities_isNumber,isObject:TreeUtilities_isObject,merge:TreeUtilities_merge,pick:TreeUtilities_pick,relativeLength:TreeUtilities_relativeLength}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();function getColor(node,options){const index=options.index,mapOptionsToLevel=options.mapOptionsToLevel,parentColor=options.parentColor,parentColorIndex=options.parentColorIndex,series=options.series,colors=options.colors,siblings=options.siblings,points=series.points,chartOptionsChart=series.chart.options.chart;let getColorByPoint,point,level,colorByPoint,colorIndexByPoint,color,colorIndex;const variateColor=color=>{const colorVariation=level&&level.colorVariation;if(colorVariation&&colorVariation.key==="brightness"&&index&&siblings){return highcharts_Color_commonjs_highcharts_Color_commonjs2_highcharts_Color_root_Highcharts_Color_default().parse(color).brighten(colorVariation.to*(index/siblings)).get()}return color};if(node){point=points[node.i];level=mapOptionsToLevel[node.level]||{};getColorByPoint=point&&level.colorByPoint;if(getColorByPoint){colorIndexByPoint=point.index%(colors?colors.length:chartOptionsChart.colorCount);colorByPoint=colors&&colors[colorIndexByPoint]}if(!series.chart.styledMode){color=TreeUtilities_pick(point&&point.options.color,level&&level.color,colorByPoint,parentColor&&variateColor(parentColor),series.color)}colorIndex=TreeUtilities_pick(point&&point.options.colorIndex,level&&level.colorIndex,colorIndexByPoint,parentColorIndex,options.colorIndex)}return{color:color,colorIndex:colorIndex}}function getLevelOptions(params){const result={};let defaults,converted,i,from,to,levels;if(TreeUtilities_isObject(params)){from=TreeUtilities_isNumber(params.from)?params.from:1;levels=params.levels;converted={};defaults=TreeUtilities_isObject(params.defaults)?params.defaults:{};if(TreeUtilities_isArray(levels)){converted=levels.reduce((obj,item)=>{let level,levelIsConstant,options;if(TreeUtilities_isObject(item)&&TreeUtilities_isNumber(item.level)){options=TreeUtilities_merge({},item);levelIsConstant=TreeUtilities_pick(options.levelIsConstant,defaults.levelIsConstant);delete options.levelIsConstant;delete options.level;level=item.level+(levelIsConstant?0:from-1);if(TreeUtilities_isObject(obj[level])){TreeUtilities_merge(true,obj[level],options)}else{obj[level]=options}}return obj},{})}to=TreeUtilities_isNumber(params.to)?params.to:1;for(i=0;i<=to;i++){result[i]=TreeUtilities_merge({},defaults,TreeUtilities_isObject(converted[i])?converted[i]:{})}}return result}function setTreeValues(tree,options){const before=options.before,idRoot=options.idRoot,mapIdToNode=options.mapIdToNode,nodeRoot=mapIdToNode[idRoot],levelIsConstant=options.levelIsConstant!==false,points=options.points,point=points[tree.i],optionsPoint=point&&point.options||{},children=[];let childrenTotal=0;tree.levelDynamic=tree.level-(levelIsConstant?0:nodeRoot.level);tree.name=TreeUtilities_pick(point&&point.name,"");tree.visible=idRoot===tree.id||options.visible===true;if(typeof before==="function"){tree=before(tree,options)}tree.children.forEach((child,i)=>{const newOptions=TreeUtilities_extend({},options);TreeUtilities_extend(newOptions,{index:i,siblings:tree.children.length,visible:tree.visible});child=setTreeValues(child,newOptions);children.push(child);if(child.visible){childrenTotal+=child.val}});const value=TreeUtilities_pick(optionsPoint.value,childrenTotal);tree.visible=value>=0&&(childrenTotal>0||tree.visible);tree.children=children;tree.childrenTotal=childrenTotal;tree.isLeaf=tree.visible&&!childrenTotal;tree.val=value;return tree}function updateRootId(series){let rootId,options;if(TreeUtilities_isObject(series)){options=TreeUtilities_isObject(series.options)?series.options:{};rootId=TreeUtilities_pick(series.rootNode,options.rootId,"");if(TreeUtilities_isObject(series.userOptions)){series.userOptions.rootId=rootId}series.rootNode=rootId}return rootId}function getNodeWidth(series,columnCount){const{chart,options}=series,{nodeDistance=0,nodeWidth=0}=options,{plotSizeX=1}=chart;if(nodeWidth==="auto"){if(typeof nodeDistance==="string"&&/%$/.test(nodeDistance)){const fraction=parseFloat(nodeDistance)/100,total=columnCount+fraction*(columnCount-1);return plotSizeX/total}const nDistance=Number(nodeDistance);return(plotSizeX+nDistance)/(columnCount||1)-nDistance}return TreeUtilities_relativeLength(nodeWidth,plotSizeX)}const TreeUtilities={getColor:getColor,getLevelOptions:getLevelOptions,getNodeWidth:getNodeWidth,setTreeValues:setTreeValues,updateRootId:updateRootId};const Series_TreeUtilities=TreeUtilities;const{getLevelOptions:TreeGridAxis_getLevelOptions}=Series_TreeUtilities;const{addEvent:TreeGridAxis_addEvent,isArray:TreeGridAxis_isArray,splat:TreeGridAxis_splat,find:TreeGridAxis_find,fireEvent:TreeGridAxis_fireEvent,isObject:TreeGridAxis_isObject,isString:TreeGridAxis_isString,merge:TreeGridAxis_merge,pick:TreeGridAxis_pick,removeEvent:TreeGridAxis_removeEvent,wrap:TreeGridAxis_wrap}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();let TickConstructor;function getBreakFromNode(node,max){const to=node.collapseEnd||0;let from=node.collapseStart||0;if(to>=max){from-=.5}return{from:from,to:to,showPoints:false}}function getTreeGridFromData(data,uniqueNames,numberOfSeries){const categories=[],collapsedNodes=[],mapOfIdToNode={},uniqueNamesEnabled=uniqueNames||false;let mapOfPosToGridNode={},posIterator=-1;const treeParams={after:function(node){const gridNode=mapOfPosToGridNode[node.pos];let height=0,descendants=0;gridNode.children.forEach(function(child){descendants+=(child.descendants||0)+1;height=Math.max((child.height||0)+1,height)});gridNode.descendants=descendants;gridNode.height=height;if(gridNode.collapsed){collapsedNodes.push(gridNode)}},before:function(node){const data=TreeGridAxis_isObject(node.data,true)?node.data:{},name=TreeGridAxis_isString(data.name)?data.name:"",parentNode=mapOfIdToNode[node.parent],parentGridNode=TreeGridAxis_isObject(parentNode,true)?mapOfPosToGridNode[parentNode.pos]:null,hasSameName=function(x){return x.name===name};let gridNode,pos;if(uniqueNamesEnabled&&TreeGridAxis_isObject(parentGridNode,true)&&!!(gridNode=TreeGridAxis_find(parentGridNode.children,hasSameName))){pos=gridNode.pos;gridNode.nodes.push(node)}else{pos=posIterator++}if(!mapOfPosToGridNode[pos]){mapOfPosToGridNode[pos]=gridNode={depth:parentGridNode?parentGridNode.depth+1:0,name:name,id:data.id,nodes:[node],children:[],pos:pos};if(pos!==-1){categories.push(name)}if(TreeGridAxis_isObject(parentGridNode,true)){parentGridNode.children.push(gridNode)}}if(TreeGridAxis_isString(node.id)){mapOfIdToNode[node.id]=node}if(gridNode&&data.collapsed===true){gridNode.collapsed=true}node.pos=pos}};const updateYValuesAndTickPos=function(map,numberOfSeries){const setValues=function(gridNode,start,result){const nodes=gridNode.nodes,padding=.5;let end=start+(start===-1?0:numberOfSeries-1);const diff=(end-start)/2,pos=start+diff;nodes.forEach(function(node){const data=node.data;if(TreeGridAxis_isObject(data,true)){data.y=start+(data.seriesIndex||0);delete data.seriesIndex}node.pos=pos});result[pos]=gridNode;gridNode.pos=pos;gridNode.tickmarkOffset=diff+padding;gridNode.collapseStart=end+padding;gridNode.children.forEach(function(child){setValues(child,end+1,result);end=(child.collapseEnd||0)-padding});gridNode.collapseEnd=end+padding;return result};return setValues(map["-1"],-1,{})};const tree=Gantt_Tree.getTree(data,treeParams);mapOfPosToGridNode=updateYValuesAndTickPos(mapOfPosToGridNode,numberOfSeries);return{categories:categories,mapOfIdToNode:mapOfIdToNode,mapOfPosToGridNode:mapOfPosToGridNode,collapsedNodes:collapsedNodes,tree:tree}}function onBeforeRender(e){const chart=e.target,axes=chart.axes;axes.filter(axis=>axis.type==="treegrid").forEach(function(axis){const options=axis.options||{},labelOptions=options.labels,uniqueNames=axis.uniqueNames,max=chart.time.parse(options.max),isDirty=!axis.treeGrid.mapOfPosToGridNode||axis.series.some(function(series){return!series.hasRendered||series.isDirtyData||series.isDirty});let numberOfSeries=0,data,treeGrid;if(isDirty){const seriesHasPrimitivePoints=[];data=axis.series.reduce(function(arr,s){const seriesData=s.options.data||[],firstPoint=seriesData[0],foundPrimitivePoint=Array.isArray(firstPoint)&&!firstPoint.find(value=>typeof value==="object");seriesHasPrimitivePoints.push(foundPrimitivePoint);if(s.visible){seriesData.forEach(function(pointOptions){if(foundPrimitivePoint||s.options.keys&&s.options.keys.length){pointOptions=s.pointClass.prototype.optionsToObject.call({series:s},pointOptions);s.pointClass.setGanttPointAliases(pointOptions,chart)}if(TreeGridAxis_isObject(pointOptions,true)){pointOptions.seriesIndex=numberOfSeries;arr.push(pointOptions)}});if(uniqueNames===true){numberOfSeries++}}return arr},[]);if(max&&data.length<max){for(let i=data.length;i<=max;i++){data.push({name:i+""})}}treeGrid=getTreeGridFromData(data,uniqueNames||false,uniqueNames===true?numberOfSeries:1);axis.categories=treeGrid.categories;axis.treeGrid.mapOfPosToGridNode=treeGrid.mapOfPosToGridNode;axis.hasNames=true;axis.treeGrid.tree=treeGrid.tree;axis.series.forEach(function(series,index){const axisData=(series.options.data||[]).map(function(d){if(seriesHasPrimitivePoints[index]||TreeGridAxis_isArray(d)&&series.options.keys&&series.options.keys.length){data.forEach(function(point){const toArray=TreeGridAxis_splat(d);if(toArray.indexOf(point.x||0)>=0&&toArray.indexOf(point.x2||0)>=0){d=point}})}return TreeGridAxis_isObject(d,true)?TreeGridAxis_merge(d):d});if(series.visible){series.setData(axisData,false)}});axis.treeGrid.mapOptionsToLevel=TreeGridAxis_getLevelOptions({defaults:labelOptions,from:1,levels:labelOptions&&labelOptions.levels,to:axis.treeGrid.tree&&axis.treeGrid.tree.height});if(e.type==="beforeRender"){axis.treeGrid.collapsedNodes=treeGrid.collapsedNodes}}})}function wrapGenerateTick(proceed,pos){const axis=this,mapOptionsToLevel=axis.treeGrid.mapOptionsToLevel||{},isTreeGrid=axis.type==="treegrid",ticks=axis.ticks;let tick=ticks[pos],levelOptions,options,gridNode;if(isTreeGrid&&axis.treeGrid.mapOfPosToGridNode){gridNode=axis.treeGrid.mapOfPosToGridNode[pos];levelOptions=mapOptionsToLevel[gridNode.depth];if(levelOptions){options={labels:levelOptions}}if(!tick&&TickConstructor){ticks[pos]=tick=new TickConstructor(axis,pos,void 0,void 0,{category:gridNode.name,tickmarkOffset:gridNode.tickmarkOffset,options:options})}else{tick.parameters.category=gridNode.name;tick.options=options;tick.addLabel()}}else{proceed.apply(axis,Array.prototype.slice.call(arguments,1))}}function wrapInit(proceed,chart,userOptions,coll){const axis=this,isTreeGrid=userOptions.type==="treegrid";if(!axis.treeGrid){axis.treeGrid=new TreeGridAxisAdditions(axis)}if(isTreeGrid){TreeGridAxis_addEvent(chart,"beforeRender",onBeforeRender);TreeGridAxis_addEvent(chart,"beforeRedraw",onBeforeRender);TreeGridAxis_addEvent(chart,"addSeries",function(e){if(e.options.data){const treeGrid=getTreeGridFromData(e.options.data,userOptions.uniqueNames||false,1);axis.treeGrid.collapsedNodes=(axis.treeGrid.collapsedNodes||[]).concat(treeGrid.collapsedNodes)}});TreeGridAxis_addEvent(axis,"foundExtremes",function(){if(axis.treeGrid.collapsedNodes){axis.treeGrid.collapsedNodes.forEach(function(node){const breaks=axis.treeGrid.collapse(node);if(axis.brokenAxis){axis.brokenAxis.setBreaks(breaks,false);if(axis.treeGrid.collapsedNodes){axis.treeGrid.collapsedNodes=axis.treeGrid.collapsedNodes.filter(n=>node.collapseStart!==n.collapseStart||node.collapseEnd!==n.collapseEnd)}}})}});TreeGridAxis_addEvent(axis,"afterBreaks",function(){if(axis.coll==="yAxis"&&!axis.staticScale&&axis.chart.options.chart.height){axis.isDirty=true}});userOptions=TreeGridAxis_merge({grid:{enabled:true},labels:{align:"left",levels:[{level:void 0},{level:1,style:{fontWeight:"bold"}}],symbol:{type:"triangle",x:-5,y:-5,height:10,width:10}},uniqueNames:false},userOptions,{reversed:true})}proceed.apply(axis,[chart,userOptions,coll]);if(isTreeGrid){axis.hasNames=true;axis.options.showLastLabel=true}}function wrapSetTickInterval(proceed){const axis=this,options=axis.options,time=axis.chart.time,linkedParent=typeof options.linkedTo==="number"?this.chart[axis.coll]?.[options.linkedTo]:void 0,isTreeGrid=axis.type==="treegrid";if(isTreeGrid){axis.min=axis.userMin??time.parse(options.min)??axis.dataMin;axis.max=axis.userMax??time.parse(options.max)??axis.dataMax;TreeGridAxis_fireEvent(axis,"foundExtremes");axis.setAxisTranslation();axis.tickInterval=1;axis.tickmarkOffset=.5;axis.tickPositions=axis.treeGrid.mapOfPosToGridNode?axis.treeGrid.getTickPositions():[];if(linkedParent){const linkedParentExtremes=linkedParent.getExtremes();axis.min=TreeGridAxis_pick(linkedParentExtremes.min,linkedParentExtremes.dataMin);axis.max=TreeGridAxis_pick(linkedParentExtremes.max,linkedParentExtremes.dataMax);axis.tickPositions=linkedParent.tickPositions}axis.linkedParent=linkedParent}else{proceed.apply(axis,Array.prototype.slice.call(arguments,1))}}function wrapRedraw(proceed){const axis=this,isTreeGrid=this.type==="treegrid";if(isTreeGrid&&axis.visible){axis.tickPositions.forEach(function(pos){const tick=axis.ticks[pos];if(tick.label&&tick.label.attachedTreeGridEvents){TreeGridAxis_removeEvent(tick.label.element);tick.label.attachedTreeGridEvents=false}})}proceed.apply(axis,Array.prototype.slice.call(arguments,1))}class TreeGridAxisAdditions{static compose(AxisClass,ChartClass,SeriesClass,TickClass){if(!AxisClass.keepProps.includes("treeGrid")){const axisProps=AxisClass.prototype;AxisClass.keepProps.push("treeGrid");TreeGridAxis_wrap(axisProps,"generateTick",wrapGenerateTick);TreeGridAxis_wrap(axisProps,"init",wrapInit);TreeGridAxis_wrap(axisProps,"setTickInterval",wrapSetTickInterval);TreeGridAxis_wrap(axisProps,"redraw",wrapRedraw);axisProps.utils={getNode:Gantt_Tree.getNode};if(!TickConstructor){TickConstructor=TickClass}}Axis_GridAxis.compose(AxisClass,ChartClass,TickClass);Axis_BrokenAxis.compose(AxisClass,SeriesClass);TreeGridTick.compose(TickClass);return AxisClass}constructor(axis){this.axis=axis}setCollapsedStatus(node){const axis=this.axis,chart=axis.chart;axis.series.forEach(function(series){const data=series.options.data;if(node.id&&data){const point=chart.get(node.id),dataPoint=data[series.data.indexOf(point)];if(point&&dataPoint){point.collapsed=node.collapsed;dataPoint.collapsed=node.collapsed}}})}collapse(node){const axis=this.axis,breaks=axis.options.breaks||[],obj=getBreakFromNode(node,axis.max);breaks.push(obj);node.collapsed=true;axis.treeGrid.setCollapsedStatus(node);return breaks}expand(node){const axis=this.axis,breaks=axis.options.breaks||[],obj=getBreakFromNode(node,axis.max);node.collapsed=false;axis.treeGrid.setCollapsedStatus(node);return breaks.reduce(function(arr,b){if(b.to!==obj.to||b.from!==obj.from){arr.push(b)}return arr},[])}getTickPositions(){const axis=this.axis,roundedMin=Math.floor(axis.min/axis.tickInterval)*axis.tickInterval,roundedMax=Math.ceil(axis.max/axis.tickInterval)*axis.tickInterval;return Object.keys(axis.treeGrid.mapOfPosToGridNode||{}).reduce(function(arr,key){const pos=+key;if(pos>=roundedMin&&pos<=roundedMax&&!(axis.brokenAxis&&axis.brokenAxis.isInAnyBreak(pos))){arr.push(pos)}return arr},[])}isCollapsed(node){const axis=this.axis,breaks=axis.options.breaks||[],obj=getBreakFromNode(node,axis.max);return breaks.some(function(b){return b.from===obj.from&&b.to===obj.to})}toggleCollapse(node){return this.isCollapsed(node)?this.expand(node):this.collapse(node)}}const TreeGridAxis=TreeGridAxisAdditions;const{series:Series,seriesTypes:{xrange:GanttSeries_XRangeSeries}}=highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default();const{extend:GanttSeries_extend,isNumber:GanttSeries_isNumber,merge:GanttSeries_merge}=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();class GanttSeries extends GanttSeries_XRangeSeries{static compose(AxisClass,ChartClass,SeriesClass,TickClass){GanttSeries_XRangeSeries.compose(AxisClass);if(!ChartClass){return}Extensions_StaticScale.compose(AxisClass,ChartClass);if(!SeriesClass){return}Gantt_Pathfinder.compose(ChartClass,SeriesClass.prototype.pointClass);if(!TickClass){return}TreeGridAxis.compose(AxisClass,ChartClass,SeriesClass,TickClass)}drawPoint(point,verb){const series=this,seriesOpts=series.options,renderer=series.chart.renderer,shapeArgs=point.shapeArgs,plotY=point.plotY,state=point.selected&&"select",cutOff=seriesOpts.stacking&&!seriesOpts.borderRadius;let graphic=point.graphic,diamondShape;if(point.options.milestone){if(GanttSeries_isNumber(plotY)&&point.y!==null&&point.visible!==false){diamondShape=renderer.symbols.diamond(shapeArgs.x||0,shapeArgs.y||0,shapeArgs.width||0,shapeArgs.height||0);if(graphic){graphic[verb]({d:diamondShape})}else{point.graphic=graphic=renderer.path(diamondShape).addClass(point.getClassName(),true).add(point.group||series.group)}if(!series.chart.styledMode){point.graphic.attr(series.pointAttribs(point,state)).shadow(seriesOpts.shadow,null,cutOff)}}else if(graphic){point.graphic=graphic.destroy()}}else{super.drawPoint(point,verb)}}translatePoint(point){let shapeArgs,size;super.translatePoint(point);if(point.options.milestone){shapeArgs=point.shapeArgs;size=shapeArgs.height||0;point.shapeArgs={x:(shapeArgs.x||0)-size/2,y:shapeArgs.y,width:size,height:size}}}}GanttSeries.defaultOptions=GanttSeries_merge(GanttSeries_XRangeSeries.defaultOptions,Gantt_GanttSeriesDefaults);GanttSeries_extend(GanttSeries.prototype,{pointArrayMap:["start","end","y"],pointClass:Gantt_GanttPoint,setData:Series.prototype.setData});highcharts_SeriesRegistry_commonjs_highcharts_SeriesRegistry_commonjs2_highcharts_SeriesRegistry_root_Highcharts_SeriesRegistry_default().registerSeriesType("gantt",GanttSeries);const Gantt_GanttSeries=GanttSeries;const gantt_src_G=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();gantt_src_G.Connection=gantt_src_G.Connection||Gantt_Connection;gantt_src_G.GanttChart=gantt_src_G.GanttChart||Chart_GanttChart;gantt_src_G.Navigator=gantt_src_G.Navigator||Navigator_Navigator;gantt_src_G.RangeSelector=gantt_src_G.RangeSelector||RangeSelector_RangeSelector;gantt_src_G.Scrollbar=gantt_src_G.Scrollbar||Scrollbar_Scrollbar;gantt_src_G.ganttChart=gantt_src_G.GanttChart.ganttChart;Extensions_ArrowSymbols.compose(gantt_src_G.SVGRenderer);Extensions_CurrentDateIndication.compose(gantt_src_G.Axis,gantt_src_G.PlotLineOrBand);Gantt_GanttSeries.compose(gantt_src_G.Axis,gantt_src_G.Chart,gantt_src_G.Series,gantt_src_G.Tick);gantt_src_G.Navigator.compose(gantt_src_G.Chart,gantt_src_G.Axis,gantt_src_G.Series);gantt_src_G.RangeSelector.compose(gantt_src_G.Axis,gantt_src_G.Chart);gantt_src_G.Scrollbar.compose(gantt_src_G.Axis);const gantt_src=highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default();__webpack_exports__=__webpack_exports__["default"];return __webpack_exports__})()});